<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wrathful Skies Simulator - Dominions 6 (v2.8.5)</title>
    <style>
        :root {
            --bg-color: #f4f6f9; 
            --surface-color: #ffffff;
            --text-color: #343a40; 
            --muted-text-color: #6c757d; 
            --primary-color-action: #007bff;
            --primary-hover-color-action: #0056b3;
            --border-color: #e9ecef;     
            --shadow-color: rgba(0,0,0,0.06);
            --font-family: "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            --graph-line1-color: #dc3545; 
            --graph-line2-color: #007bff; 
            --graph-internal-grid-color: #ced4da; /* More visible grid lines */
        }
        body { font-family: var(--font-family); line-height: 1.6; margin: 0; background-color: var(--bg-color); color: var(--text-color); display: flex; justify-content: center; padding: 20px; min-height: 100vh; box-sizing: border-box; }
        .simulator-container { background-color: var(--surface-color); padding: 30px; border-radius: 12px; box-shadow: 0 8px 25px var(--shadow-color); width: 100%; max-width: 980px; }
        header h1 { color: var(--text-color); text-align: center; margin-top: 0; margin-bottom: 30px; font-size: 1.8em; font-weight: 600; letter-spacing: -0.5px; }
        .main-content { display: flex; flex-wrap: wrap; gap: 30px; margin-bottom: 30px; }
        .input-panel, .output-panel { flex: 1; min-width: 340px; }
        .input-panel { padding: 25px; background-color: #fcfdff; border: 1px solid var(--border-color); border-radius: 8px; }
        .output-panel h2 { margin-top: 0; margin-bottom: 25px; font-size: 1.3em; color: var(--text-color); border-bottom: 1px solid var(--border-color); padding-bottom: 12px; font-weight: 500; }
        .input-group { display: flex; align-items: center; margin-bottom: 15px; flex-wrap: wrap; }
        .input-group label { flex: 0 0 190px; margin-bottom: 0; font-weight: 500; font-size: 0.9em; color: var(--muted-text-color); padding-right: 10px; box-sizing: border-box; line-height: 1.3; }
        .input-group label .main-label-text { color: var(--text-color); display: block; font-weight: 500; font-size: 0.95em;}
        .input-group label small { display: block; font-size: 0.8em; font-weight: normal; line-height: 1.2; color: #88929b; margin-top: 2px; }
        .checkbox-group { margin-bottom: 20px; padding-top: 12px; border-top: 1px dashed var(--border-color); }
        .checkbox-group .input-group { display: block; margin-bottom: 8px; }
        .input-group input[type="number"] { flex: 1; min-width: 80px; padding: 9px 12px; box-sizing: border-box; border: 1px solid #ced4da; border-radius: 6px; font-size: 0.95em; transition: border-color 0.2s, box-shadow 0.2s; }
        .input-group input[type="checkbox"] + label { display: inline-flex; align-items:center; margin-left: 8px; font-weight: normal; font-size: 0.95em; color: var(--text-color); vertical-align: middle; cursor: pointer; }
        .input-group input[type="checkbox"] + label small { font-size: 0.85em; color: var(--muted-text-color); display: inline; margin-top: 0; margin-left: 5px; }
        .input-group input[type="checkbox"] { vertical-align: middle; width: 17px; height: 17px; accent-color: var(--primary-color-action); }
        .input-group input[type="number"]:focus { border-color: var(--primary-color-action); box-shadow: 0 0 0 0.2rem rgba(0,123,255,.2); outline: none; }
        .action-button { display: block; width: 100%; padding: 12px 15px; background-color: var(--primary-color-action); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1.1em; font-weight: 500; transition: background-color 0.2s, transform 0.1s; margin-top: 25px; }
        .action-button:hover { background-color: var(--primary-hover-color-action); }
        .action-button:active { transform: translateY(1px); }
        .action-button:disabled { background-color: #adb5bd; cursor: not-allowed; }
        .results-summary { padding: 15px; background-color: #f8f9fa; border-radius: 6px; border: 1px solid var(--border-color); }
        .stat-group { margin-bottom: 15px; }
        .stat-group:last-child { margin-bottom: 0; }
        .stat-group h4 { font-size: 0.9em; color: var(--primary-color-action); margin-top:0; margin-bottom:8px; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid #e0e0e0; padding-bottom: 5px;}
        .stat-item { display: flex; justify-content: space-between; padding: 4px 0; font-size: 0.95em; margin-bottom: 2px; }
        .stat-label { color: var(--muted-text-color); flex-basis: 70%; text-align: left; padding-right: 10px; }
        .stat-value { color: var(--text-color); font-weight: 500; flex-basis: 30%; text-align: right; }
        
        #survivalGraphContainer { padding: 20px; background-color: #fdfdff; border: 1px solid var(--border-color); border-radius: 8px; box-shadow: 0 4px 12px var(--shadow-color); }
        #survivalGraphContainer h3 { margin-top: 0; margin-bottom: 20px; font-size: 1.2em; color: var(--text-color); font-weight: 500; text-align: center; }
        .graph-svg { display: block; margin: 0 auto; max-width: 100%; }
        .graph-axis.boundary-line, .graph-axis.tick-line { 
            fill: none; 
            stroke: var(--muted-text-color); 
            stroke-width: 1px; 
            shape-rendering: crispEdges; 
        }
        .graph-grid-line { 
            fill: none; 
            stroke: var(--graph-internal-grid-color); 
            stroke-width: 0.5px; 
            shape-rendering: crispEdges; 
        }
        .graph-axis text { font-size: 10px; fill: var(--muted-text-color); }
        .graph-line { fill: none; stroke-width: 2; }
        .graph-line.line1 { stroke: var(--graph-line1-color); }
        .graph-line.line2 { stroke: var(--graph-line2-color); }
        .graph-legend { font-size: 0.9em; margin-top: 15px; text-align: center;}
        .legend-item { display: inline-block; margin-right: 20px; }
        .legend-color-box { display: inline-block; width: 12px; height: 12px; margin-right: 5px; vertical-align: middle; border: 1px solid var(--border-color); }
    </style>
</head>
<body>
    <div class="simulator-container">
        <header><h1>Wrathful Skies Simulator</h1></header>
        <div class="main-content">
            <div class="input-panel">
                <h2>Unit & Scenario Configuration</h2>
                <div class="input-group">
                    <label for="unitMaxHp"><span class="main-label-text">Unit Max HP</span></label>
                    <input type="number" id="unitMaxHp" value="10" min="1">
                </div>
                <div class="input-group">
                    <label for="unitSR"><span class="main-label-text">Unit Shock Resistance (SR)</span></label>
                    <input type="number" id="unitSR" value="0" min="0">
                </div>
                <div class="input-group">
                    <label for="hpRegenPerTurn"><span class="main-label-text">HP Gained Per Turn</span><small>(Applied end of turn)</small></label>
                    <input type="number" id="hpRegenPerTurn" value="0" min="0" step="any">
                </div>
                <hr style="border: none; border-top: 1px dashed var(--border-color); margin: 20px 0;">
                <div class="input-group">
                    <label for="maxTurnsToSimulate"><span class="main-label-text">Max Turns to Simulate</span><small>(Per run, if unit survives)</small></label>
                    <input type="number" id="maxTurnsToSimulate" value="100" min="1">
                </div>
                <div class="input-group">
                    <label for="simulationRuns"><span class="main-label-text">Simulation Runs</span></label>
                    <input type="number" id="simulationRuns" value="10000" min="1">
                </div>
                <div class="checkbox-group">
                     <div class="input-group">
                        <input type="checkbox" id="stormActive" checked>
                        <label for="stormActive">Storm Spell Active? <small>(Doubles strike area)</small></label>
                    </div>
                    <div class="input-group">
                        <input type="checkbox" id="hasLuck">
                        <label for="hasLuck">Luck? <small>(75% to nullify a killing strike's damage)</small></label>
                    </div>
                </div>
                <button class="action-button" onclick="startWrathfulSkiesSimulation()">Run Simulation</button>
            </div>
            <div class="output-panel"> 
                <h2>Simulation Results</h2>
                <div id="results" class="results-summary"><p>Results will appear here after simulation.</p></div>
            </div>
        </div>
        <div id="survivalGraphContainer">
             <h3>Survival & Death Probability Over Time</h3>
             <svg id="survivalGraphSvg" class="graph-svg" width="100%" height="350"></svg> 
             <div class="graph-legend">
                <span class="legend-item"><span class="legend-color-box" style="background-color:var(--graph-line1-color);"></span>Dying in Turn X</span>
                <span class="legend-item"><span class="legend-color-box" style="background-color:var(--graph-line2-color);"></span>Cumulative Dead by Turn X</span>
             </div>
        </div>
        <details>
            <summary>Documentation & How It Works</summary>
            <div class="docs-content">
                 <!-- ... (documentation content same as before) ... -->
                 <p><strong>New in v2.8.5:</strong></p>
                 <ul>
                    <li>Changed "Luck" behavior: If enabled, the unit has a 75% chance to nullify the *damage* from a Wrathful Skies strike that would have been a killing blow. The stun effect from such a hit (if any) still applies. Luck can trigger multiple times in a run.</li>
                 </ul>
                 <p><strong>New in v2.8.4:</strong></p>
                 <ul>
                    <li>Added a "Luck" option. If enabled, the unit has a 75% chance to completely nullify a Wrathful Skies strike that would have otherwise been a killing blow. This includes negating the damage and any potential stun from that specific strike. Luck can trigger multiple times in a run.</li>
                 </ul>
            </div>
        </details>
    </div>
    <script>
        const TICKS_PER_WRATHFUL_SKIES_EVENT = 320; const TICKS_PER_TURN = 7500;
        const EVENTS_PER_TURN_RAW = TICKS_PER_TURN / TICKS_PER_WRATHFUL_SKIES_EVENT;
        const BASE_HIT_CHANCE_PER_EVENT_OPPORTUNITY = 0.003; const STORM_HIT_CHANCE_PER_EVENT_OPPORTUNITY = 0.006;
        const WRATHFUL_SKIES_BASE_DAMAGE_COMPONENT = 15;
        const STUN_CHANCE_BASE = 0.05; const MAX_DRN_ITERATIONS = 20;
        const LUCK_CHANCE = 0.75;

        function rollD6() { return Math.floor(Math.random() * 6) + 1; }
        function calculateDRN() { 
            let d1 = rollD6(), d2 = rollD6(), total = d1 + d2, iterations, currentDieVal;
            currentDieVal = d1; iterations = 0;
            while (currentDieVal === 6 && iterations < MAX_DRN_ITERATIONS) { total -= 1; currentDieVal = rollD6(); total += currentDieVal; iterations++; }
            currentDieVal = d2; iterations = 0;
            while (currentDieVal === 6 && iterations < MAX_DRN_ITERATIONS) { total -= 1; currentDieVal = rollD6(); total += currentDieVal; iterations++; }
            return total;
        }
        function calculateWrathfulSkiesHitOutcome(unitSR, currentUnitHp, unitMaxHp) {
            const DRN1 = calculateDRN(); const DRN2 = calculateDRN();
            const rawDamagePreSR = WRATHFUL_SKIES_BASE_DAMAGE_COMPONENT + DRN1 - DRN2;
            const totalSRReduction = unitSR * 1.3; 
            const damageAfterSRForAvg = Math.max(0, rawDamagePreSR - totalSRReduction); // Potential damage after SR
            const actualHpLost = Math.min(damageAfterSRForAvg, currentUnitHp); // HP that would be lost, capped by current HP
            
            let stunned = false;
            // Stun chance is based on damageAfterSRForAvg (potential damage if unit had infinite HP),
            // but only if some HP would actually be lost (actualHpLost > 0).
            // This interpretation ensures stun reflects the "severity" of the hit before Luck.
            if (damageAfterSRForAvg > 0 && unitMaxHp > 0) { // Check potential damage for stun severity
                const stunChance = STUN_CHANCE_BASE + (damageAfterSRForAvg / unitMaxHp) / 2; 
                if (Math.random() < stunChance) stunned = true;
            }
            // If actualHpLost is 0 (e.g. damageAfterSRForAvg was 0, or currentUnitHp was 0), it definitely shouldn't stun.
            if (actualHpLost <= 0) stunned = false;

            return { actualHpLost, stunned, damageAfterSRForAvg };
        }

        function simulateTurnEvents(currentHp, unitMaxHp, unitSR, stormActive, numEventOpportunitiesThisTurn, hasLuck) {
            let hpAfterEvents = currentHp;
            let wsHitsThisTurn = 0; 
            let stunsThisTurn = 0;
            let allHitDamageValuesThisTurn = []; 
            let luckSavesThisTurn = 0;

            const effectiveHitChance = stormActive ? STORM_HIT_CHANCE_PER_EVENT_OPPORTUNITY : BASE_HIT_CHANCE_PER_EVENT_OPPORTUNITY;

            for (let i = 0; i < numEventOpportunitiesThisTurn; i++) {
                if (hpAfterEvents <= 0) break; 

                if (Math.random() < effectiveHitChance) { 
                    wsHitsThisTurn++;
                    const outcome = calculateWrathfulSkiesHitOutcome(unitSR, hpAfterEvents, unitMaxHp);
                    
                    let damageToApply = outcome.actualHpLost;
                    let wasStunnedByThisHit = outcome.stunned; // Stun is determined before Luck
                    let hitWasNullifiedByLuck = false;

                    // Check for Luck activation if it's a killing blow
                    if (hasLuck && hpAfterEvents > 0 && (hpAfterEvents - damageToApply <= 0) && damageToApply > 0) {
                        if (Math.random() < LUCK_CHANCE) { // 75% chance for Luck
                            damageToApply = 0;     // Nullify damage
                            // wasStunnedByThisHit remains as calculated by outcome.stunned
                            luckSavesThisTurn++;
                            hitWasNullifiedByLuck = true;
                        }
                    }

                    if (!hitWasNullifiedByLuck && outcome.damageAfterSRForAvg > 0) {
                        allHitDamageValuesThisTurn.push(outcome.damageAfterSRForAvg);
                    }
                    
                    if (damageToApply > 0) {
                        hpAfterEvents -= damageToApply;
                    }

                    if (wasStunnedByThisHit) { // Stun applies even if damage was nullified by Luck
                        stunsThisTurn++;
                    }
                }
            }
            return { 
                hpAfterDamageEvents: hpAfterEvents, 
                wsHitsInTurn: wsHitsThisTurn, 
                stunsInTurn: stunsThisTurn, 
                hitDamageValues: allHitDamageValuesThisTurn,
                luckSavesInTurn: luckSavesThisTurn 
            };
        }

        function simulateOneFullRun(unitMaxHp, unitSR, hpRegenPerTurnFloat, stormActive, maxTurns, hasLuck) {
            let currentHp = unitMaxHp; let turnsCompleted = 0; 
            let totalWsHits = 0; let totalStunsSustained = 0;
            let allHitDamageValuesInRun = []; let died = false;
            let eventOpportunitiesAccumulator = 0; 
            let hpRegenAccumulator = 0;
            let totalLuckSavesInRun = 0;

            for (let t = 0; t < maxTurns; t++) {
                eventOpportunitiesAccumulator += EVENTS_PER_TURN_RAW;
                const eventsToProcessThisTurn = Math.floor(eventOpportunitiesAccumulator);
                eventOpportunitiesAccumulator -= eventsToProcessThisTurn; 
                
                const turnOutcome = simulateTurnEvents(currentHp, unitMaxHp, unitSR, stormActive, eventsToProcessThisTurn, hasLuck);
                currentHp = turnOutcome.hpAfterDamageEvents; 
                totalWsHits += turnOutcome.wsHitsInTurn; 
                totalStunsSustained += turnOutcome.stunsInTurn; 
                allHitDamageValuesInRun.push(...turnOutcome.hitDamageValues);
                totalLuckSavesInRun += turnOutcome.luckSavesInTurn;

                if (currentHp <= 0) { died = true; turnsCompleted = t; break; } 
                
                if (hpRegenPerTurnFloat > 0) {
                    hpRegenAccumulator += hpRegenPerTurnFloat;
                    const actualHpToRegenThisTurn = Math.floor(hpRegenAccumulator);
                    if (actualHpToRegenThisTurn > 0) {
                        currentHp += actualHpToRegenThisTurn;
                        currentHp = Math.min(currentHp, unitMaxHp);
                        hpRegenAccumulator -= actualHpToRegenThisTurn;
                    }
                }
                turnsCompleted = t + 1; 
            }
            return { 
                numTurnsCompleted: turnsCompleted, 
                died: died, 
                turnOfDeath: died ? turnsCompleted : -1, 
                totalWsHits: totalWsHits, 
                totalStuns: totalStunsSustained, 
                allHitDamageValues: allHitDamageValuesInRun,
                totalLuckSaves: totalLuckSavesInRun
            };
        }

        function startWrathfulSkiesSimulation() {
            document.querySelectorAll('.input-panel input[type="number"]').forEach(input => input.style.borderColor = '');
            const unitMaxHpInput = document.getElementById('unitMaxHp'); 
            const unitSRInput = document.getElementById('unitSR');
            const hpRegenPerTurnInput = document.getElementById('hpRegenPerTurn'); 
            const maxTurnsToSimulateInput = document.getElementById('maxTurnsToSimulate');
            const simulationRunsInput = document.getElementById('simulationRuns'); 
            const stormActive = document.getElementById('stormActive').checked;
            const hasLuck = document.getElementById('hasLuck').checked;

            let isValid = true;
            const inputsToValidate = [ 
                { el: unitMaxHpInput, min: 1, name: "Unit Max HP" }, 
                { el: unitSRInput, min: 0, name: "Unit SR" }, 
                { el: maxTurnsToSimulateInput, min: 1, name: "Max Turns to Simulate" }, 
                { el: simulationRunsInput, min: 1, name: "Simulation Runs" }
            ];
            let errorMessages = [];
            inputsToValidate.forEach(item => { 
                const value = parseInt(item.el.value); 
                if (item.el.value === "" || isNaN(value) || value < item.min) { 
                    item.el.style.borderColor = 'red'; 
                    isValid = false; 
                    errorMessages.push(`${item.name} must be a number >= ${item.min}.`);
                }
            });
            const hpRegenValue = parseFloat(hpRegenPerTurnInput.value);
            if (hpRegenPerTurnInput.value === "" || isNaN(hpRegenValue) || hpRegenValue < 0) { 
                hpRegenPerTurnInput.style.borderColor = 'red'; 
                isValid = false; 
                errorMessages.push(`HP Gained Per Turn must be a number >= 0.`);
            }

            const resultsDiv = document.getElementById('results'); 
            const svgGraphElement = document.getElementById('survivalGraphSvg');
            if (!isValid) { 
                resultsDiv.innerHTML = `<p style='color:red; padding: 10px;'>Please correct the highlighted fields. Errors:<br>- ${errorMessages.join('<br>- ')}</p>`; 
                svgGraphElement.innerHTML = '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--muted-text-color)">Graph requires valid inputs.</text>'; 
                return; 
            }

            const unitMaxHp = parseInt(unitMaxHpInput.value); 
            const unitSR = parseInt(unitSRInput.value);
            const maxTurns = parseInt(maxTurnsToSimulateInput.value); 
            const numRuns = parseInt(simulationRunsInput.value);

            resultsDiv.innerHTML = "<p style='padding:10px;'>Running simulation, please wait...</p>"; 
            svgGraphElement.innerHTML = '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--muted-text-color)">Generating graph...</text>';
            document.querySelector('.action-button').disabled = true;

            setTimeout(() => {
                try {
                    let sumOfTurnsCompleted = 0; let deathCount = 0;
                    let totalWsHitsSum = 0; let totalStunsSum = 0;
                    let allHitDamageValuesAcrossRuns = [];
                    let deathsAtTurnT_array = new Array(maxTurns).fill(0);
                    let allSurvivalLengths = []; 
                    let totalLuckSavesSum = 0;

                    for (let i = 0; i < numRuns; i++) {
                        const runResult = simulateOneFullRun(unitMaxHp, unitSR, hpRegenValue, stormActive, maxTurns, hasLuck);
                        sumOfTurnsCompleted += runResult.numTurnsCompleted;
                        allSurvivalLengths.push(runResult.numTurnsCompleted); 
                        if (runResult.died) { 
                            deathCount++; 
                            if (runResult.turnOfDeath >= 0 && runResult.turnOfDeath < maxTurns) { 
                                deathsAtTurnT_array[runResult.turnOfDeath]++; 
                            }
                        }
                        totalWsHitsSum += runResult.totalWsHits; 
                        totalStunsSum += runResult.totalStuns;
                        allHitDamageValuesAcrossRuns.push(...runResult.allHitDamageValues);
                        totalLuckSavesSum += runResult.totalLuckSaves;
                    }

                    const avgSurvivalLength = sumOfTurnsCompleted / numRuns;
                    const deathPercentage = (deathCount / numRuns) * 100;
                    let stdDevSurvivalLength = 0;
                    if (numRuns > 1) { 
                        let sumOfSquaredDifferences = 0;
                        for (const length of allSurvivalLengths) { sumOfSquaredDifferences += Math.pow(length - avgSurvivalLength, 2); }
                        const variance = sumOfSquaredDifferences / numRuns; 
                        stdDevSurvivalLength = Math.sqrt(variance);
                    }
                    const survivalPlus1Std = avgSurvivalLength + stdDevSurvivalLength;
                    const survivalMinus1Std = Math.max(0, avgSurvivalLength - stdDevSurvivalLength);
                    const survivalPlus2Std = avgSurvivalLength + (2 * stdDevSurvivalLength);
                    const survivalMinus2Std = Math.max(0, avgSurvivalLength - (2 * stdDevSurvivalLength));
                    
                    const avgTotalWsHitsPerRun = totalWsHitsSum / numRuns;
                    const avgWsHitsPerTurnSurvived = sumOfTurnsCompleted > 0 ? totalWsHitsSum / sumOfTurnsCompleted : 0;
                    
                    let avgDamagePerWsHit = 0; 
                    if (allHitDamageValuesAcrossRuns.length > 0) { 
                        avgDamagePerWsHit = allHitDamageValuesAcrossRuns.reduce((sum, val) => sum + val, 0) / allHitDamageValuesAcrossRuns.length; 
                    }
                    
                    const avgStunsPerRun = totalStunsSum / numRuns;
                    const avgStunsPerTurnSurvived = sumOfTurnsCompleted > 0 ? totalStunsSum / sumOfTurnsCompleted : 0;
                    const avgLuckSavesPerRun = totalLuckSavesSum / numRuns;

                    let outputHTML = `<div class="stat-group"><h4>Overall Statistics (per Run)</h4>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Total Simulation Runs:</span><span class="stat-value">${numRuns}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Unit Died in Runs:</span><span class="stat-value">${deathCount} (${deathPercentage.toFixed(1)}%)</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Survival Length (completed turns):</span><span class="stat-value">${avgSurvivalLength.toFixed(2)}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Std. Dev. of Survival Length:</span><span class="stat-value">${stdDevSurvivalLength.toFixed(2)}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">    Avg ± 1 Std Dev Range:</span><span class="stat-value">${survivalMinus1Std.toFixed(2)} - ${survivalPlus1Std.toFixed(2)}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">    Avg ± 2 Std Dev Range:</span><span class="stat-value">${survivalMinus2Std.toFixed(2)} - ${survivalPlus2Std.toFixed(2)}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Wrathful Skies Hit Attempts:</span><span class="stat-value">${avgTotalWsHitsPerRun.toFixed(2)}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Stuns:</span><span class="stat-value">${avgStunsPerRun.toFixed(2)}</span></div>`;
                    if (hasLuck) {
                        outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Luck Saves (damage nullified):</span><span class="stat-value">${avgLuckSavesPerRun.toFixed(2)}</span></div>`;
                    }
                    outputHTML += `</div>`;
                    
                    outputHTML += `<div class="stat-group"><h4>Per-Turn Statistics (avg. over survived turns)</h4>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Wrathful Skies Hit Attempts (per Turn):</span><span class="stat-value">${avgWsHitsPerTurnSurvived.toFixed(3)}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Stuns (per Turn):</span><span class="stat-value">${avgStunsPerTurnSurvived.toFixed(3)}</span></div></div>`;
                    
                    outputHTML += `<div class="stat-group"><h4>Wrathful Skies Hit Details</h4>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Damage per Non-Lucked WS Hit:</span><span class="stat-value">${avgDamagePerWsHit.toFixed(2)}</span></div></div>`;
                    resultsDiv.innerHTML = outputHTML;

                    let probDyingInTurnT_graphData = []; let cumulativeProbDeadByTurnT_graphData = [];
                    let cumulativeDeaths = 0;
                    for (let t = 0; t < maxTurns; t++) { 
                        probDyingInTurnT_graphData.push((deathsAtTurnT_array[t] / numRuns) * 100); 
                        cumulativeDeaths += deathsAtTurnT_array[t]; 
                        cumulativeProbDeadByTurnT_graphData.push((cumulativeDeaths / numRuns) * 100); 
                    }
                    drawSurvivalGraph(svgGraphElement, maxTurns, probDyingInTurnT_graphData, cumulativeProbDeadByTurnT_graphData);
                } catch (error) { 
                    resultsDiv.innerHTML = `<p style="color:red; padding:10px;">An error occurred: ${error.message}</p><pre>${error.stack}</pre>`; 
                    svgGraphElement.innerHTML = `<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--muted-text-color)">Error generating graph.</text>`; 
                    console.error("Simulation error:", error);
                } finally { 
                    document.querySelector('.action-button').disabled = false; 
                }
            }, 10);
        }

        function drawSurvivalGraph(svgElement, maxTurnsToGraph, probDyingInTurnT_data, cumulativeProbDeadByTurnT_data) {
            svgElement.innerHTML = ''; 
            const svgNS = "http://www.w3.org/2000/svg";
            const actualWidth = svgElement.parentElement.clientWidth; 
            svgElement.setAttribute('width', actualWidth);
            const height = parseInt(svgElement.getAttribute('height'));
            const margin = { top: 20, right: 30, bottom: 50, left: 60 };
            const graphWidth = actualWidth - margin.left - margin.right;
            const graphHeight = height - margin.top - margin.bottom;

            if (graphWidth <=0 || graphHeight <=0) { svgElement.innerHTML = '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--muted-text-color)">Not enough space for graph.</text>'; return; }
            const numDataPoints = maxTurnsToGraph;
            if (numDataPoints === 0) { svgElement.innerHTML = '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--muted-text-color)">No data for graph.</text>'; return;}

            const xScale = (turnIndex) => margin.left + (turnIndex / (numDataPoints > 1 ? numDataPoints - 1 : 1)) * graphWidth;
            const yScale = (percentage) => margin.top + graphHeight - (percentage / 100) * graphHeight;
            
            const gridGroup = document.createElementNS(svgNS, 'g'); 
            gridGroup.setAttribute('class', 'graph-grid'); 
            svgElement.appendChild(gridGroup);
            
            const xAxisLine = document.createElementNS(svgNS, 'line'); 
            xAxisLine.setAttributes({ x1: margin.left, y1: margin.top + graphHeight, x2: margin.left + graphWidth, y2: margin.top + graphHeight, class: 'graph-axis boundary-line' }); 
            svgElement.appendChild(xAxisLine);
            const yAxisLine = document.createElementNS(svgNS, 'line'); 
            yAxisLine.setAttributes({ x1: margin.left, y1: margin.top, x2: margin.left, y2: margin.top + graphHeight, class: 'graph-axis boundary-line' }); 
            svgElement.appendChild(yAxisLine);

            const numXTicks = Math.min(10, numDataPoints > 0 ? numDataPoints : 1);
            for (let i = 0; i <= numXTicks; i++) {
                const turnVal = numDataPoints > 1 ? Math.round(i * (numDataPoints - 1) / numXTicks) : (numDataPoints === 1 ? 0 : i) ;
                const x = xScale(turnVal);
                const tick = document.createElementNS(svgNS, 'line'); 
                tick.setAttributes({ x1: x, y1: margin.top + graphHeight, x2: x, y2: margin.top + graphHeight + 6, class: 'graph-axis tick-line' }); 
                svgElement.appendChild(tick);
                const label = document.createElementNS(svgNS, 'text'); 
                label.setAttributes({ x: x, y: margin.top + graphHeight + 20, 'text-anchor': 'middle', class: 'graph-axis' }); 
                label.textContent = turnVal; 
                svgElement.appendChild(label);
                if (Math.abs(x - margin.left) > 1e-6 && Math.abs(x - (margin.left + graphWidth)) > 1e-6) { 
                    const gridLine = document.createElementNS(svgNS, 'line'); 
                    gridLine.setAttributes({ x1: x, y1: margin.top, x2: x, y2: margin.top + graphHeight, class: 'graph-grid-line' }); 
                    gridGroup.appendChild(gridLine);
                }
            }
            const xAxisLabel = document.createElementNS(svgNS, 'text'); 
            xAxisLabel.setAttributes({x: margin.left + graphWidth/2, y: height - 10, 'text-anchor':'middle', class:'graph-axis', 'font-weight':'500'}); 
            xAxisLabel.textContent = "Turn Number"; 
            svgElement.appendChild(xAxisLabel);

            for (let i = 0; i <= 10; i++) { 
                const perc = i * 10; 
                const y = yScale(perc);
                const tick = document.createElementNS(svgNS, 'line'); 
                tick.setAttributes({ x1: margin.left - 6, y1: y, x2: margin.left, y2: y, class: 'graph-axis tick-line' }); 
                svgElement.appendChild(tick);
                const label = document.createElementNS(svgNS, 'text'); 
                label.setAttributes({ x: margin.left - 10, y: y, 'text-anchor': 'end', 'dominant-baseline': 'middle', class: 'graph-axis' }); 
                label.textContent = perc + '%'; 
                svgElement.appendChild(label);
                if (Math.abs(y - (margin.top + graphHeight)) > 1e-6 && Math.abs(y - margin.top) > 1e-6) {
                    const gridLine = document.createElementNS(svgNS, 'line'); 
                    gridLine.setAttributes({ x1: margin.left, y1: y, x2: margin.left + graphWidth, y2: y, class: 'graph-grid-line' }); 
                    gridGroup.appendChild(gridLine);
                }
            }
            
            const createPointsString = (data, xMap, yMap) => data.map((d, i) => `${xMap(i).toFixed(2)},${yMap(d).toFixed(2)}`).join(' ');
            if (probDyingInTurnT_data.length > 0) { 
                const polyline1 = document.createElementNS(svgNS, 'polyline'); 
                polyline1.setAttribute('points', createPointsString(probDyingInTurnT_data, xScale, yScale)); 
                polyline1.setAttribute('class', 'graph-line line1'); 
                svgElement.appendChild(polyline1); 
            }
            if (cumulativeProbDeadByTurnT_data.length > 0) { 
                const polyline2 = document.createElementNS(svgNS, 'polyline'); 
                polyline2.setAttribute('points', createPointsString(cumulativeProbDeadByTurnT_data, xScale, yScale)); 
                polyline2.setAttribute('class', 'graph-line line2'); 
                svgElement.appendChild(polyline2); 
            }
        }
        Element.prototype.setAttributes = function (attrs) { for (var key in attrs) this.setAttribute(key, attrs[key]); };
    </script>
</body>
</html>
