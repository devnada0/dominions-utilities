<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wrathful Skies Simulator - Dominions 6</title>
    <style>
        :root {
            --bg-color: #f4f6f9; 
            --surface-color: #ffffff;
            --text-color: #343a40; 
            --muted-text-color: #6c757d; 
            --primary-color-action: #007bff;
            --primary-hover-color-action: #0056b3;
            --border-color: #e9ecef;     
            --shadow-color: rgba(0,0,0,0.06);
            --font-family: "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            --graph-line1-color: #dc3545; 
            --graph-line2-color: #007bff; 
            --graph-internal-grid-color: #ced4da; /* More visible grid lines */
        }
        body { font-family: var(--font-family); line-height: 1.6; margin: 0; background-color: var(--bg-color); color: var(--text-color); display: flex; justify-content: center; padding: 20px; min-height: 100vh; box-sizing: border-box; }
        .simulator-container { background-color: var(--surface-color); padding: 30px; border-radius: 12px; box-shadow: 0 8px 25px var(--shadow-color); width: 100%; max-width: 980px; }
        header h1 { color: var(--text-color); text-align: center; margin-top: 0; margin-bottom: 30px; font-size: 1.8em; font-weight: 600; letter-spacing: -0.5px; }
        .main-content { display: flex; flex-wrap: wrap; gap: 30px; margin-bottom: 30px; }
        .input-panel, .output-panel { flex: 1; min-width: 340px; }
        .input-panel { padding: 25px; background-color: #fcfdff; border: 1px solid var(--border-color); border-radius: 8px; }
        .output-panel h2 { margin-top: 0; margin-bottom: 25px; font-size: 1.3em; color: var(--text-color); border-bottom: 1px solid var(--border-color); padding-bottom: 12px; font-weight: 500; }
        .input-group { display: flex; align-items: center; margin-bottom: 15px; flex-wrap: wrap; }
        .input-group label { flex: 0 0 190px; margin-bottom: 0; font-weight: 500; font-size: 0.9em; color: var(--muted-text-color); padding-right: 10px; box-sizing: border-box; line-height: 1.3; }
        .input-group label .main-label-text { color: var(--text-color); display: block; font-weight: 500; font-size: 0.95em;}
        .input-group label small { display: block; font-size: 0.8em; font-weight: normal; line-height: 1.2; color: #88929b; margin-top: 2px; }
        .checkbox-group { margin-bottom: 20px; padding-top: 12px; border-top: 1px dashed var(--border-color); }
        .checkbox-group .input-group { display: block; margin-bottom: 8px; }
        .input-group input[type="number"] { flex: 1; min-width: 80px; padding: 9px 12px; box-sizing: border-box; border: 1px solid #ced4da; border-radius: 6px; font-size: 0.95em; transition: border-color 0.2s, box-shadow 0.2s; }
        .input-group input[type="checkbox"] + label { display: inline-flex; align-items:center; margin-left: 8px; font-weight: normal; font-size: 0.95em; color: var(--text-color); vertical-align: middle; cursor: pointer; }
        .input-group input[type="checkbox"] + label small { font-size: 0.85em; color: var(--muted-text-color); display: inline; margin-top: 0; margin-left: 5px; }
        .input-group input[type="checkbox"] { vertical-align: middle; width: 17px; height: 17px; accent-color: var(--primary-color-action); }
        .input-group input[type="number"]:focus { border-color: var(--primary-color-action); box-shadow: 0 0 0 0.2rem rgba(0,123,255,.2); outline: none; }
        .action-button { display: block; width: 100%; padding: 12px 15px; background-color: var(--primary-color-action); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1.1em; font-weight: 500; transition: background-color 0.2s, transform 0.1s; margin-top: 25px; }
        .action-button:hover { background-color: var(--primary-hover-color-action); }
        .action-button:active { transform: translateY(1px); }
        .action-button:disabled { background-color: #adb5bd; cursor: not-allowed; }
        .results-summary { padding: 15px; background-color: #f8f9fa; border-radius: 6px; border: 1px solid var(--border-color); }
        .stat-group { margin-bottom: 15px; }
        .stat-group:last-child { margin-bottom: 0; }
        .stat-group h4 { font-size: 0.9em; color: var(--primary-color-action); margin-top:0; margin-bottom:8px; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid #e0e0e0; padding-bottom: 5px;}
        .stat-item { display: flex; justify-content: space-between; padding: 4px 0; font-size: 0.95em; margin-bottom: 2px; }
        .stat-label { color: var(--muted-text-color); flex-basis: 70%; text-align: left; padding-right: 10px; }
        .stat-value { color: var(--text-color); font-weight: 500; flex-basis: 30%; text-align: right; }
        
        #survivalGraphContainer { padding: 20px; background-color: #fdfdff; border: 1px solid var(--border-color); border-radius: 8px; box-shadow: 0 4px 12px var(--shadow-color); }
        #survivalGraphContainer h3 { margin-top: 0; margin-bottom: 20px; font-size: 1.2em; color: var(--text-color); font-weight: 500; text-align: center; }
        .graph-svg { display: block; margin: 0 auto; max-width: 100%; }
        .graph-axis.boundary-line, .graph-axis.tick-line { 
            fill: none; 
            stroke: var(--muted-text-color); 
            stroke-width: 1px; 
            shape-rendering: crispEdges; 
        }
        .graph-grid-line { 
            fill: none; 
            stroke: var(--graph-internal-grid-color); 
            stroke-width: 0.5px; 
            shape-rendering: crispEdges; 
        }
        .graph-axis text { font-size: 10px; fill: var(--muted-text-color); }
        .graph-line { fill: none; stroke-width: 2; }
        .graph-line.line1 { stroke: var(--graph-line1-color); }
        .graph-line.line2 { stroke: var(--graph-line2-color); }
        .graph-legend { font-size: 0.9em; margin-top: 15px; text-align: center;}
        .legend-item { display: inline-block; margin-right: 20px; }
        .legend-color-box { display: inline-block; width: 12px; height: 12px; margin-right: 5px; vertical-align: middle; border: 1px solid var(--border-color); }
        /* Styles for details/summary */
        details { margin-top: 30px; border: 1px solid var(--border-color); border-radius: 8px; padding: 15px 20px; background-color: var(--surface-color); }
        summary { font-weight: 500; cursor: pointer; margin-bottom: 10px; color: var(--text-color); font-size: 1.05em; list-style: none; position: relative; padding-left: 25px; }
        summary::-webkit-details-marker { display: none; } 
        summary::before { content: 'â–¶'; position: absolute; left: 0; font-size: 0.9em; transition: transform 0.2s ease-in-out; color: var(--muted-text-color); }
        details[open] summary::before { transform: rotate(90deg); }
        summary:hover { color: var(--primary-color-action); }
        .docs-content { font-size: 0.9em; line-height: 1.6; padding-top: 15px; border-top: 1px solid var(--border-color); color: var(--muted-text-color); }
        .docs-content h4 { margin-top: 15px; margin-bottom: 8px; border-bottom: 1px solid #e9ecef; padding-bottom: 5px; color: var(--text-color); font-size: 1em; font-weight: 500; }
        .docs-content h4:first-of-type { margin-top: 0; }
        .docs-content p, .docs-content ul, .docs-content ol { margin-bottom: 10px; }
        .docs-content ul, .docs-content ol { padding-left: 25px; }
        .docs-content li { margin-bottom: 5px; }
        .docs-content code { background-color: #e9ecef; padding: 2px 6px; border-radius: 4px; font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; font-size: 0.9em; color: #007bff; }
    </style>
</head>
<body>
    <div class="simulator-container">
        <header><h1>Wrathful Skies Simulator</h1></header>
        <div class="main-content">
            <div class="input-panel">
                <h2>Unit & Scenario Configuration</h2>
                <div class="input-group">
                    <label for="unitMaxHp"><span class="main-label-text">Unit Max HP</span></label>
                    <input type="number" id="unitMaxHp" value="10" min="1">
                </div>
                <div class="input-group">
                    <label for="unitSR"><span class="main-label-text">Unit Shock Resistance (SR)</span></label>
                    <input type="number" id="unitSR" value="0" min="0">
                </div>
                <div class="input-group">
                    <label for="hpRegenPerTurn"><span class="main-label-text">HP Gained Per Turn</span><small>(Applied end of turn)</small></label>
                    <input type="number" id="hpRegenPerTurn" value="0" min="0" step="any">
                </div>
                <hr style="border: none; border-top: 1px dashed var(--border-color); margin: 20px 0;">
                <div class="input-group">
                    <label for="maxTurnsToSimulate"><span class="main-label-text">Max Turns to Simulate</span><small>(Per run, if unit survives)</small></label>
                    <input type="number" id="maxTurnsToSimulate" value="100" min="1">
                </div>
                <div class="input-group">
                    <label for="simulationRuns"><span class="main-label-text">Simulation Runs</span></label>
                    <input type="number" id="simulationRuns" value="10000" min="1">
                </div>
                <div class="checkbox-group">
                     <div class="input-group">
                        <input type="checkbox" id="stormActive" checked>
                        <label for="stormActive">Storm Spell Active? <small>(Doubles strike area)</small></label>
                    </div>
                    <div class="input-group">
                        <input type="checkbox" id="hasLuck">
                        <label for="hasLuck">Luck? <small>(75% to nullify a killing strike's damage)</small></label>
                    </div>
                </div>
                <button class="action-button" onclick="startWrathfulSkiesSimulation()">Run Simulation</button>
            </div>
            <div class="output-panel"> 
                <h2>Simulation Results</h2>
                <div id="results" class="results-summary"><p>Results will appear here after simulation.</p></div>
            </div>
        </div>
        <div id="survivalGraphContainer">
             <h3>Survival & Death Probability Over Time</h3>
             <svg id="survivalGraphSvg" class="graph-svg" width="100%" height="350"></svg> 
             <div class="graph-legend">
                <span class="legend-item"><span class="legend-color-box" style="background-color:var(--graph-line1-color);"></span>Dying in Turn X</span>
                <span class="legend-item"><span class="legend-color-box" style="background-color:var(--graph-line2-color);"></span>Cumulative Dead by Turn X</span>
             </div>
        </div>
        <details open>
            <summary>Documentation & How It Works</summary>
            <div class="docs-content">
                <h4>Purpose:</h4>
                <p>This tool simulates the impact of the Wrathful Skies battlefield enchantment on a single unit over multiple turns and simulation runs. It helps estimate survivability against this spell, considering unit HP, Shock Resistance, regeneration, the Storm spell, and Luck.</p>

                <h4>How to Use (Inputs):</h4>
                <ul>
                    <li><strong>Unit Max HP:</strong> The starting and maximum Hit Points of the unit. (Default: 10, Min: 1)</li>
                    <li><strong>Unit Shock Resistance (SR):</strong> The unit's Shock Resistance value. Reduces damage from Wrathful Skies. (Default: 0, Min: 0)</li>
                    <li><strong>HP Gained Per Turn:</strong> Amount of HP the unit regenerates at the end of each full turn. Accepts fractional values (e.g., 0.5). (Default: 0, Min: 0)</li>
                    <li><strong>Max Turns to Simulate:</strong> The maximum number of turns a single simulation run will last if the unit survives that long. (Default: 100, Min: 1)</li>
                    <li><strong>Simulation Runs:</strong> Number of times to run the full simulation sequence for statistical analysis. Higher numbers give more accurate averages but take longer. (Default: 10000, Min: 1)</li>
                    <li><strong>Storm Spell Active?:</strong> If checked, the global enchantment "Storm" is assumed to be active, doubling the effective area and thus the chance of Wrathful Skies striking. (Default: Checked)</li>
                    <li><strong>Luck?:</strong> If checked, the unit possesses Luck, granting a 75% chance to nullify the damage from a Wrathful Skies strike that would otherwise be a killing blow. The stun from such a hit (if any) still applies. (Default: Unchecked)</li>
                </ul>

                <h4>Mechanics Modeled:</h4>
                <ol>
                    <li><strong>Simulation Run vs. Turn:</strong>
                        <ul>
                            <li>A "Simulation Run" is one complete instance of simulating the unit's fate from Turn 0 up to either its death or the "Max Turns to Simulate" limit.</li>
                            <li>A "Turn" represents one round of combat in Dominions.</li>
                        </ul>
                    </li>
                    <li><strong>Wrathful Skies Event Timing:</strong>
                        <ul>
                            <li>Wrathful Skies has an opportunity to strike every 320 "game ticks".</li>
                            <li>A Dominions turn consists of 7500 "game ticks".</li>
                            <li>This results in <code>7500 / 320 = 23.4375</code> potential strike opportunities per turn. The simulator handles the fractional part by accumulating it across turns.</li>
                        </ul>
                    </li>
                    <li><strong>Chance for Unit to be Hit per Opportunity:</strong>
                        <ul>
                            <li>Base chance: 0.3% (<code>0.003</code>) per opportunity.</li>
                            <li>If "Storm Spell Active?" is checked: 0.6% (<code>0.006</code>) per opportunity.</li>
                        </ul>
                    </li>
                    <li><strong>DRN (Dice Roll Notation):</strong>
                        <ul>
                            <li>Wrathful Skies damage involves <code>DRN1 - DRN2</code>.</li>
                            <li>A DRN is calculated by rolling two six-sided dice (2d6). If a die shows a 6, it's re-rolled and the new result is added, minus 1 (to account for the 6 being part of the sum already). This "exploding die" mechanic is applied iteratively up to 20 times per initial die to prevent infinite loops in extreme cases.</li>
                        </ul>
                    </li>
                    <li><strong>Wrathful Skies Hit Outcome:</strong>
                        <ol style="list-style-type: lower-alpha; padding-left: 20px;">
                            <li><strong>Initial Damage Roll:</strong> Calculated as <code>15 + DRN1 - DRN2</code>.</li>
                            <li><strong>Shock Resistance (SR) Application (Two-Part):</strong>
                                <ol style="list-style-type: lower-roman; padding-left: 20px;">
                                    <li>The Initial Damage Roll is first reduced directly by <code>Unit SR</code>.</li>
                                    <li>Then, an additional amount is subtracted. This amount is <code>Unit SR * 2%</code> of the spell's original base damage component (which is 15 for Wrathful Skies), rounded normally. So, <code>Math.round(Unit SR * 0.02 * 15)</code> or <code>Math.round(Unit SR * 0.3)</code> is subtracted.</li>
                                </ol>
                            </li>
                            <li><strong>Damage After SR:</strong> The result from the SR application, floored at 0 (<code>Math.max(0, damage)</code>). This value is referred to as <code>damageAfterSRForAvg</code> in the code and is used for stun calculations and averaging.</li>
                            <li><strong>Actual HP Lost:</strong> The <code>Damage After SR</code>, but capped at the unit's current HP. This is the amount of HP the unit would lose from the hit *before* considering Luck.</li>
                            <li><strong>Stun Chance:</strong> If <code>Damage After SR</code> is greater than 0, a stun check is made. The chance to be stunned is <code>0.05 + (Damage After SR / Unit Max HP) / 2</code>. If the unit is stunned, it's recorded. Note that <code>Damage After SR</code> (the potential damage if the unit had infinite HP) is used for calculating stun severity, not the HP-capped <code>Actual HP Lost</code>. However, if <code>Actual HP Lost</code> would be 0 (e.g. unit already dead, or damage fully resisted), no stun occurs from that hit.</li>
                        </ol>
                    </li>
                    <li><strong>Luck Mechanic:</strong>
                        <ul>
                            <li>If "Luck?" is checked and a Wrathful Skies hit would reduce the unit's HP to 0 or less (a killing blow):
                                <ul>
                                    <li>There is a 75% chance for Luck to trigger.</li>
                                    <li>If Luck triggers, the <code>Actual HP Lost</code> from that specific hit is set to 0. The unit takes no damage from that hit.</li>
                                    <li>The stun (if any was rolled for that hit based on its pre-Luck potential damage) *still applies*.</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li><strong>HP Regeneration:</strong>
                        <ul>
                            <li>If "HP Gained Per Turn" is greater than 0, this amount is added to the unit's current HP at the very end of each turn, after all Wrathful Skies events for that turn have resolved.</li>
                            <li>Regeneration cannot exceed the unit's "Unit Max HP".</li>
                            <li>Fractional regeneration values accumulate until a whole point of HP can be regenerated.</li>
                        </ul>
                    </li>
                </ol>

                <h4>Output Statistics & Graph:</h4>
                <ul>
                    <li><strong>Overall Statistics:</strong> Summarizes averages per simulation run, including survival length, death rates, total hits, stuns, and Luck saves. Standard deviation for survival length is also provided.</li>
                    <li><strong>Per-Turn Statistics:</strong> Shows average hits and stuns per survived turn.</li>
                    <li><strong>Wrathful Skies Hit Details:</strong> Displays the average damage dealt by Wrathful Skies hits that were not nullified by Luck and dealt more than 0 damage.</li>
                    <li><strong>Survival & Death Probability Graph:</strong>
                        <ul>
                            <li>The X-axis represents the turn number, up to "Max Turns to Simulate".</li>
                            <li>The Y-axis represents probability (0% to 100%).</li>
                            <li><strong>Red Line ("Dying in Turn X"):</strong> Shows the percentage of simulation runs where the unit died specifically *in* that turn.</li>
                            <li><strong>Blue Line ("Cumulative Dead by Turn X"):</strong> Shows the total percentage of simulation runs where the unit had died by the end of that turn (or earlier).</li>
                        </ul>
                    </li>
                </ul>

                <h4>Known Limitations:</h4>
                <ul>
                    <li>Only simulates a single unit against Wrathful Skies. No squad mechanics.</li>
                    <li>Does not model morale, afflictions (other than stun from WS), or other battlefield spells/effects.</li>
                    <li>DRN explosion is capped at 20 iterations per die to prevent extremely rare infinite loops.</li>
                    <li>Assumes Wrathful Skies is the only source of damage or effects on the unit.</li>
                </ul>
            </div>
        </details>
    </div>
    <script>
        const TICKS_PER_WRATHFUL_SKIES_EVENT = 320; const TICKS_PER_TURN = 7500;
        const EVENTS_PER_TURN_RAW = TICKS_PER_TURN / TICKS_PER_WRATHFUL_SKIES_EVENT;
        const BASE_HIT_CHANCE_PER_EVENT_OPPORTUNITY = 0.003; const STORM_HIT_CHANCE_PER_EVENT_OPPORTUNITY = 0.006;
        const WRATHFUL_SKIES_BASE_DAMAGE_COMPONENT = 15;
        const STUN_CHANCE_BASE = 0.05; const MAX_DRN_ITERATIONS = 20;
        const LUCK_CHANCE = 0.75;

        function rollD6() { return Math.floor(Math.random() * 6) + 1; }
        function calculateDRN() { 
            let d1 = rollD6(), d2 = rollD6(), total = d1 + d2, iterations, currentDieVal;
            currentDieVal = d1; iterations = 0;
            while (currentDieVal === 6 && iterations < MAX_DRN_ITERATIONS) { total -= 1; currentDieVal = rollD6(); total += currentDieVal; iterations++; }
            currentDieVal = d2; iterations = 0;
            while (currentDieVal === 6 && iterations < MAX_DRN_ITERATIONS) { total -= 1; currentDieVal = rollD6(); total += currentDieVal; iterations++; }
            return total;
        }
        
        function calculateWrathfulSkiesHitOutcome(unitSR, currentUnitHp, unitMaxHp) {
            const DRN1 = calculateDRN(); const DRN2 = calculateDRN();
            const initialDamageRoll = WRATHFUL_SKIES_BASE_DAMAGE_COMPONENT + DRN1 - DRN2;
            
            // Part 1: Direct SR Subtraction
            let damageAfterDirectSR = initialDamageRoll - unitSR;

            // Part 2: Percentage-based reduction (SR * 2% of base spell damage 15, rounded)
            const percentageBasedReductionAmount = Math.round(unitSR * 0.02 * WRATHFUL_SKIES_BASE_DAMAGE_COMPONENT); // Math.round(unitSR * 0.3)
            
            const damageAfterAllSR = damageAfterDirectSR - percentageBasedReductionAmount;
            const damageAfterSRForAvg = Math.max(0, damageAfterAllSR); // This is the potential damage after all SR, floored at 0. Used for stun & avg damage stat.
            
            const actualHpLost = Math.min(damageAfterSRForAvg, currentUnitHp); // HP lost, capped by current HP, before Luck.
            
            let stunned = false;
            // Stun chance is based on damageAfterSRForAvg (potential damage if unit had infinite HP),
            // but only if this potential damage is > 0.
            if (damageAfterSRForAvg > 0 && unitMaxHp > 0) { 
                const stunChance = STUN_CHANCE_BASE + (damageAfterSRForAvg / unitMaxHp) / 2; 
                if (Math.random() < stunChance) stunned = true;
            }
            // If damageAfterSRForAvg was 0 (meaning fully resisted or negative initial roll), no stun.
            // This also covers if actualHpLost would be 0 because currentHp is 0.

            return { actualHpLost, stunned, damageAfterSRForAvg };
        }

        function simulateTurnEvents(currentHp, unitMaxHp, unitSR, stormActive, numEventOpportunitiesThisTurn, hasLuck) {
            let hpAfterEvents = currentHp;
            let wsHitsThisTurn = 0; 
            let stunsThisTurn = 0;
            let allHitDamageValuesThisTurn = []; 
            let luckSavesThisTurn = 0;

            const effectiveHitChance = stormActive ? STORM_HIT_CHANCE_PER_EVENT_OPPORTUNITY : BASE_HIT_CHANCE_PER_EVENT_OPPORTUNITY;

            for (let i = 0; i < numEventOpportunitiesThisTurn; i++) {
                if (hpAfterEvents <= 0) break; 

                if (Math.random() < effectiveHitChance) { 
                    wsHitsThisTurn++;
                    // currentHp sent to calculateWrathfulSkiesHitOutcome is used to cap actualHpLost before Luck.
                    const outcome = calculateWrathfulSkiesHitOutcome(unitSR, hpAfterEvents, unitMaxHp);
                    
                    let damageToApply = outcome.actualHpLost; 
                    let wasStunnedByThisHit = outcome.stunned;
                    let hitWasNullifiedByLuck = false;

                    if (hasLuck && hpAfterEvents > 0 && (hpAfterEvents - damageToApply <= 0) && damageToApply > 0) {
                        if (Math.random() < LUCK_CHANCE) { 
                            damageToApply = 0;     
                            luckSavesThisTurn++;
                            hitWasNullifiedByLuck = true;
                        }
                    }

                    // We record damageAfterSRForAvg for the "Avg Damage per Non-Lucked WS Hit" stat
                    // only if it wasn't Lucked and it had some potential damage.
                    if (!hitWasNullifiedByLuck && outcome.damageAfterSRForAvg > 0) {
                        allHitDamageValuesThisTurn.push(outcome.damageAfterSRForAvg);
                    }
                    
                    if (damageToApply > 0) {
                        hpAfterEvents -= damageToApply;
                    }

                    if (wasStunnedByThisHit) { 
                        stunsThisTurn++;
                    }
                }
            }
            return { 
                hpAfterDamageEvents: hpAfterEvents, 
                wsHitsInTurn: wsHitsThisTurn, 
                stunsInTurn: stunsThisTurn, 
                hitDamageValues: allHitDamageValuesThisTurn,
                luckSavesInTurn: luckSavesThisTurn 
            };
        }

        function simulateOneFullRun(unitMaxHp, unitSR, hpRegenPerTurnFloat, stormActive, maxTurns, hasLuck) {
            let currentHp = unitMaxHp; let turnsCompleted = 0; 
            let totalWsHits = 0; let totalStunsSustained = 0;
            let allHitDamageValuesInRun = []; let died = false;
            let eventOpportunitiesAccumulator = 0; 
            let hpRegenAccumulator = 0;
            let totalLuckSavesInRun = 0;

            for (let t = 0; t < maxTurns; t++) {
                eventOpportunitiesAccumulator += EVENTS_PER_TURN_RAW;
                const eventsToProcessThisTurn = Math.floor(eventOpportunitiesAccumulator);
                eventOpportunitiesAccumulator -= eventsToProcessThisTurn; 
                
                const turnOutcome = simulateTurnEvents(currentHp, unitMaxHp, unitSR, stormActive, eventsToProcessThisTurn, hasLuck);
                currentHp = turnOutcome.hpAfterDamageEvents; 
                totalWsHits += turnOutcome.wsHitsInTurn; 
                totalStunsSustained += turnOutcome.stunsInTurn; 
                allHitDamageValuesInRun.push(...turnOutcome.hitDamageValues);
                totalLuckSavesInRun += turnOutcome.luckSavesInTurn;

                if (currentHp <= 0) { died = true; turnsCompleted = t; break; } 
                
                if (hpRegenPerTurnFloat > 0) {
                    hpRegenAccumulator += hpRegenPerTurnFloat;
                    const actualHpToRegenThisTurn = Math.floor(hpRegenAccumulator);
                    if (actualHpToRegenThisTurn > 0) {
                        currentHp += actualHpToRegenThisTurn;
                        currentHp = Math.min(currentHp, unitMaxHp);
                        hpRegenAccumulator -= actualHpToRegenThisTurn;
                    }
                }
                turnsCompleted = t + 1; 
            }
            return { 
                numTurnsCompleted: turnsCompleted, 
                died: died, 
                turnOfDeath: died ? turnsCompleted : -1, 
                totalWsHits: totalWsHits, 
                totalStuns: totalStunsSustained, 
                allHitDamageValues: allHitDamageValuesInRun,
                totalLuckSaves: totalLuckSavesInRun
            };
        }

        function startWrathfulSkiesSimulation() {
            document.querySelectorAll('.input-panel input[type="number"]').forEach(input => input.style.borderColor = '');
            const unitMaxHpInput = document.getElementById('unitMaxHp'); 
            const unitSRInput = document.getElementById('unitSR');
            const hpRegenPerTurnInput = document.getElementById('hpRegenPerTurn'); 
            const maxTurnsToSimulateInput = document.getElementById('maxTurnsToSimulate');
            const simulationRunsInput = document.getElementById('simulationRuns'); 
            const stormActive = document.getElementById('stormActive').checked;
            const hasLuck = document.getElementById('hasLuck').checked;

            let isValid = true;
            const inputsToValidate = [ 
                { el: unitMaxHpInput, min: 1, name: "Unit Max HP" }, 
                { el: unitSRInput, min: 0, name: "Unit SR" }, 
                { el: maxTurnsToSimulateInput, min: 1, name: "Max Turns to Simulate" }, 
                { el: simulationRunsInput, min: 1, name: "Simulation Runs" }
            ];
            let errorMessages = [];
            inputsToValidate.forEach(item => { 
                const value = parseInt(item.el.value); 
                if (item.el.value === "" || isNaN(value) || value < item.min) { 
                    item.el.style.borderColor = 'red'; 
                    isValid = false; 
                    errorMessages.push(`${item.name} must be a number >= ${item.min}.`);
                }
            });
            const hpRegenValue = parseFloat(hpRegenPerTurnInput.value);
            if (hpRegenPerTurnInput.value === "" || isNaN(hpRegenValue) || hpRegenValue < 0) { 
                hpRegenPerTurnInput.style.borderColor = 'red'; 
                isValid = false; 
                errorMessages.push(`HP Gained Per Turn must be a number >= 0.`);
            }

            const resultsDiv = document.getElementById('results'); 
            const svgGraphElement = document.getElementById('survivalGraphSvg');
            if (!isValid) { 
                resultsDiv.innerHTML = `<p style='color:red; padding: 10px;'>Please correct the highlighted fields. Errors:<br>- ${errorMessages.join('<br>- ')}</p>`; 
                svgGraphElement.innerHTML = '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--muted-text-color)">Graph requires valid inputs.</text>'; 
                return; 
            }

            const unitMaxHp = parseInt(unitMaxHpInput.value); 
            const unitSR = parseInt(unitSRInput.value);
            const maxTurns = parseInt(maxTurnsToSimulateInput.value); 
            const numRuns = parseInt(simulationRunsInput.value);

            resultsDiv.innerHTML = "<p style='padding:10px;'>Running simulation, please wait...</p>"; 
            svgGraphElement.innerHTML = '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--muted-text-color)">Generating graph...</text>';
            document.querySelector('.action-button').disabled = true;

            setTimeout(() => {
                try {
                    let sumOfTurnsCompleted = 0; let deathCount = 0;
                    let totalWsHitsSum = 0; let totalStunsSum = 0;
                    let allHitDamageValuesAcrossRuns = [];
                    let deathsAtTurnT_array = new Array(maxTurns).fill(0);
                    let allSurvivalLengths = []; 
                    let totalLuckSavesSum = 0;

                    for (let i = 0; i < numRuns; i++) {
                        const runResult = simulateOneFullRun(unitMaxHp, unitSR, hpRegenValue, stormActive, maxTurns, hasLuck);
                        sumOfTurnsCompleted += runResult.numTurnsCompleted;
                        allSurvivalLengths.push(runResult.numTurnsCompleted); 
                        if (runResult.died) { 
                            deathCount++; 
                            if (runResult.turnOfDeath >= 0 && runResult.turnOfDeath < maxTurns) { 
                                deathsAtTurnT_array[runResult.turnOfDeath]++; 
                            }
                        }
                        totalWsHitsSum += runResult.totalWsHits; 
                        totalStunsSum += runResult.totalStuns;
                        allHitDamageValuesAcrossRuns.push(...runResult.allHitDamageValues);
                        totalLuckSavesSum += runResult.totalLuckSaves;
                    }

                    const avgSurvivalLength = sumOfTurnsCompleted / numRuns;
                    const deathPercentage = (deathCount / numRuns) * 100;
                    let stdDevSurvivalLength = 0;
                    if (numRuns > 1) { 
                        let sumOfSquaredDifferences = 0;
                        for (const length of allSurvivalLengths) { sumOfSquaredDifferences += Math.pow(length - avgSurvivalLength, 2); }
                        const variance = sumOfSquaredDifferences / numRuns; 
                        stdDevSurvivalLength = Math.sqrt(variance);
                    }
                    const survivalPlus1Std = avgSurvivalLength + stdDevSurvivalLength;
                    const survivalMinus1Std = Math.max(0, avgSurvivalLength - stdDevSurvivalLength);
                    const survivalPlus2Std = avgSurvivalLength + (2 * stdDevSurvivalLength);
                    const survivalMinus2Std = Math.max(0, avgSurvivalLength - (2 * stdDevSurvivalLength));
                    
                    const avgTotalWsHitsPerRun = totalWsHitsSum / numRuns;
                    const avgWsHitsPerTurnSurvived = sumOfTurnsCompleted > 0 ? totalWsHitsSum / sumOfTurnsCompleted : 0;
                    
                    let avgDamagePerWsHit = 0; 
                    if (allHitDamageValuesAcrossRuns.length > 0) { 
                        avgDamagePerWsHit = allHitDamageValuesAcrossRuns.reduce((sum, val) => sum + val, 0) / allHitDamageValuesAcrossRuns.length; 
                    }
                    
                    const avgStunsPerRun = totalStunsSum / numRuns;
                    const avgStunsPerTurnSurvived = sumOfTurnsCompleted > 0 ? totalStunsSum / sumOfTurnsCompleted : 0;
                    const avgLuckSavesPerRun = totalLuckSavesSum / numRuns;

                    let outputHTML = `<div class="stat-group"><h4>Overall Statistics (per Run)</h4>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Total Simulation Runs:</span><span class="stat-value">${numRuns}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Unit Died in Runs:</span><span class="stat-value">${deathCount} (${deathPercentage.toFixed(1)}%)</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Survival Length (completed turns):</span><span class="stat-value">${avgSurvivalLength.toFixed(2)}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Std. Dev. of Survival Length:</span><span class="stat-value">${stdDevSurvivalLength.toFixed(2)}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Â Â Â Â Avg Â± 1 Std Dev Range:</span><span class="stat-value">${survivalMinus1Std.toFixed(2)} - ${survivalPlus1Std.toFixed(2)}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Â Â Â Â Avg Â± 2 Std Dev Range:</span><span class="stat-value">${survivalMinus2Std.toFixed(2)} - ${survivalPlus2Std.toFixed(2)}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Wrathful Skies Hit Attempts:</span><span class="stat-value">${avgTotalWsHitsPerRun.toFixed(2)}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Stuns:</span><span class="stat-value">${avgStunsPerRun.toFixed(2)}</span></div>`;
                    if (hasLuck) { 
                        outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Luck Saves (damage nullified):</span><span class="stat-value">${avgLuckSavesPerRun.toFixed(2)}</span></div>`;
                    }
                    outputHTML += `</div>`;
                    
                    outputHTML += `<div class="stat-group"><h4>Per-Turn Statistics (avg. over survived turns)</h4>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Wrathful Skies Hit Attempts (per Turn):</span><span class="stat-value">${avgWsHitsPerTurnSurvived.toFixed(3)}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Stuns (per Turn):</span><span class="stat-value">${avgStunsPerTurnSurvived.toFixed(3)}</span></div></div>`;
                    
                    outputHTML += `<div class="stat-group"><h4>Wrathful Skies Hit Details</h4>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Damage per Non-Lucked WS Hit:</span><span class="stat-value">${avgDamagePerWsHit.toFixed(2)}</span></div></div>`;
                    resultsDiv.innerHTML = outputHTML;

                    let probDyingInTurnT_graphData = []; let cumulativeProbDeadByTurnT_graphData = [];
                    let cumulativeDeaths = 0;
                    for (let t = 0; t < maxTurns; t++) { 
                        probDyingInTurnT_graphData.push((deathsAtTurnT_array[t] / numRuns) * 100); 
                        cumulativeDeaths += deathsAtTurnT_array[t]; 
                        cumulativeProbDeadByTurnT_graphData.push((cumulativeDeaths / numRuns) * 100); 
                    }
                    drawSurvivalGraph(svgGraphElement, maxTurns, probDyingInTurnT_graphData, cumulativeProbDeadByTurnT_graphData);
                } catch (error) { 
                    resultsDiv.innerHTML = `<p style="color:red; padding:10px;">An error occurred: ${error.message}</p><pre>${error.stack}</pre>`; 
                    svgGraphElement.innerHTML = `<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--muted-text-color)">Error generating graph.</text>`; 
                    console.error("Simulation error:", error);
                } finally { 
                    document.querySelector('.action-button').disabled = false; 
                }
            }, 10);
        }

        function drawSurvivalGraph(svgElement, maxTurnsToGraph, probDyingInTurnT_data, cumulativeProbDeadByTurnT_data) {
            svgElement.innerHTML = ''; 
            const svgNS = "http://www.w3.org/2000/svg";
            const actualWidth = svgElement.parentElement.clientWidth; 
            svgElement.setAttribute('width', actualWidth);
            const height = parseInt(svgElement.getAttribute('height'));
            const margin = { top: 20, right: 30, bottom: 50, left: 60 };
            const graphWidth = actualWidth - margin.left - margin.right;
            const graphHeight = height - margin.top - margin.bottom;

            if (graphWidth <=0 || graphHeight <=0) { svgElement.innerHTML = '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--muted-text-color)">Not enough space for graph.</text>'; return; }
            const numDataPoints = maxTurnsToGraph;
            if (numDataPoints === 0) { svgElement.innerHTML = '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--muted-text-color)">No data for graph.</text>'; return;}

            const xScale = (turnIndex) => margin.left + (turnIndex / (numDataPoints > 1 ? numDataPoints - 1 : 1)) * graphWidth;
            const yScale = (percentage) => margin.top + graphHeight - (percentage / 100) * graphHeight;
            
            const gridGroup = document.createElementNS(svgNS, 'g'); 
            gridGroup.setAttribute('class', 'graph-grid'); 
            svgElement.appendChild(gridGroup);
            
            const xAxisLine = document.createElementNS(svgNS, 'line'); 
            xAxisLine.setAttributes({ x1: margin.left, y1: margin.top + graphHeight, x2: margin.left + graphWidth, y2: margin.top + graphHeight, class: 'graph-axis boundary-line' }); 
            svgElement.appendChild(xAxisLine);
            const yAxisLine = document.createElementNS(svgNS, 'line'); 
            yAxisLine.setAttributes({ x1: margin.left, y1: margin.top, x2: margin.left, y2: margin.top + graphHeight, class: 'graph-axis boundary-line' }); 
            svgElement.appendChild(yAxisLine);

            const numXTicks = Math.min(10, numDataPoints > 0 ? numDataPoints : 1);
            for (let i = 0; i <= numXTicks; i++) {
                const turnVal = numDataPoints > 1 ? Math.round(i * (numDataPoints - 1) / numXTicks) : (numDataPoints === 1 ? 0 : i) ;
                const x = xScale(turnVal);
                const tick = document.createElementNS(svgNS, 'line'); 
                tick.setAttributes({ x1: x, y1: margin.top + graphHeight, x2: x, y2: margin.top + graphHeight + 6, class: 'graph-axis tick-line' }); 
                svgElement.appendChild(tick);
                const label = document.createElementNS(svgNS, 'text'); 
                label.setAttributes({ x: x, y: margin.top + graphHeight + 20, 'text-anchor': 'middle', class: 'graph-axis' }); 
                label.textContent = turnVal; 
                svgElement.appendChild(label);
                if (Math.abs(x - margin.left) > 1e-6 && Math.abs(x - (margin.left + graphWidth)) > 1e-6) { 
                    const gridLine = document.createElementNS(svgNS, 'line'); 
                    gridLine.setAttributes({ x1: x, y1: margin.top, x2: x, y2: margin.top + graphHeight, class: 'graph-grid-line' }); 
                    gridGroup.appendChild(gridLine);
                }
            }
            const xAxisLabel = document.createElementNS(svgNS, 'text'); 
            xAxisLabel.setAttributes({x: margin.left + graphWidth/2, y: height - 10, 'text-anchor':'middle', class:'graph-axis', 'font-weight':'500'}); 
            xAxisLabel.textContent = "Turn Number"; 
            svgElement.appendChild(xAxisLabel);

            for (let i = 0; i <= 10; i++) { 
                const perc = i * 10; 
                const y = yScale(perc);
                const tick = document.createElementNS(svgNS, 'line'); 
                tick.setAttributes({ x1: margin.left - 6, y1: y, x2: margin.left, y2: y, class: 'graph-axis tick-line' }); 
                svgElement.appendChild(tick);
                const label = document.createElementNS(svgNS, 'text'); 
                label.setAttributes({ x: margin.left - 10, y: y, 'text-anchor': 'end', 'dominant-baseline': 'middle', class: 'graph-axis' }); 
                label.textContent = perc + '%'; 
                svgElement.appendChild(label);
                if (Math.abs(y - (margin.top + graphHeight)) > 1e-6 && Math.abs(y - margin.top) > 1e-6) {
                    const gridLine = document.createElementNS(svgNS, 'line'); 
                    gridLine.setAttributes({ x1: margin.left, y1: y, x2: margin.left + graphWidth, y2: y, class: 'graph-grid-line' }); 
                    gridGroup.appendChild(gridLine);
                }
            }
            
            const createPointsString = (data, xMap, yMap) => data.map((d, i) => `${xMap(i).toFixed(2)},${yMap(d).toFixed(2)}`).join(' ');
            if (probDyingInTurnT_data.length > 0) { 
                const polyline1 = document.createElementNS(svgNS, 'polyline'); 
                polyline1.setAttribute('points', createPointsString(probDyingInTurnT_data, xScale, yScale)); 
                polyline1.setAttribute('class', 'graph-line line1'); 
                svgElement.appendChild(polyline1); 
            }
            if (cumulativeProbDeadByTurnT_data.length > 0) { 
                const polyline2 = document.createElementNS(svgNS, 'polyline'); 
                polyline2.setAttribute('points', createPointsString(cumulativeProbDeadByTurnT_data, xScale, yScale)); 
                polyline2.setAttribute('class', 'graph-line line2'); 
                svgElement.appendChild(polyline2); 
            }
        }
        Element.prototype.setAttributes = function (attrs) { for (var key in attrs) this.setAttribute(key, attrs[key]); };
    </script>
</body>
</html>
