<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fire Storm Simulator - Dominions 6 (with Luck)</title>
    <style>
        /* CSS is identical to v2.9.3/v2.9.7 - no changes needed here */
        :root {
            --bg-color: #f4f6f9; 
            --surface-color: #ffffff;
            --text-color: #343a40; 
            --muted-text-color: #6c757d;
            --primary-color-action: #dc3545; /* Red theme for fire */
            --primary-hover-color-action: #c82333;
            --border-color: #e9ecef;     
            --shadow-color: rgba(0,0,0,0.06);
            --font-family: "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            --graph-line1-color: #e67e22; 
            --graph-line2-color: #c0392b; 
            --graph-internal-grid-color: #ced4da; 
        }
        body { font-family: var(--font-family); line-height: 1.6; margin: 0; background-color: var(--bg-color); color: var(--text-color); display: flex; justify-content: center; padding: 20px; min-height: 100vh; box-sizing: border-box; }
        .simulator-container { background-color: var(--surface-color); padding: 30px; border-radius: 12px; box-shadow: 0 8px 25px var(--shadow-color); width: 100%; max-width: 980px; }
        header h1 { color: var(--text-color); text-align: center; margin-top: 0; margin-bottom: 30px; font-size: 1.8em; font-weight: 600; letter-spacing: -0.5px; }
        .main-content { display: flex; flex-wrap: wrap; gap: 30px; margin-bottom: 30px; }
        .input-panel, .output-panel { flex: 1; min-width: 340px; }
        .input-panel { padding: 25px; background-color: #fcfdff; border: 1px solid var(--border-color); border-radius: 8px; }
        .output-panel h2 { margin-top: 0; margin-bottom: 25px; font-size: 1.3em; color: var(--text-color); border-bottom: 1px solid var(--border-color); padding-bottom: 12px; font-weight: 500; }
        .input-group { display: flex; align-items: center; margin-bottom: 15px; flex-wrap: wrap; }
        .input-group label { flex: 0 0 190px; margin-bottom: 0; font-weight: 500; font-size: 0.9em; color: var(--muted-text-color); padding-right: 10px; box-sizing: border-box; line-height: 1.3; }
        .input-group label .main-label-text { color: var(--text-color); display: block; font-weight: 500; font-size: 0.95em;}
        .input-group label small { display: block; font-size: 0.8em; font-weight: normal; line-height: 1.2; color: #88929b; margin-top: 2px; }
        .checkbox-group { margin-bottom: 20px; padding-top: 12px; border-top: 1px dashed var(--border-color); }
        .checkbox-group .input-group { display: block; margin-bottom: 8px; }
        .input-group input[type="number"], .input-group select { flex: 1; min-width: 80px; padding: 9px 12px; box-sizing: border-box; border: 1px solid #ced4da; border-radius: 6px; font-size: 0.95em; transition: border-color 0.2s, box-shadow 0.2s; }
        .input-group input[type="checkbox"] + label { display: inline-flex; align-items:center; margin-left: 8px; font-weight: normal; font-size: 0.95em; color: var(--text-color); vertical-align: middle; cursor: pointer; }
        .input-group input[type="checkbox"] + label small { font-size: 0.85em; color: var(--muted-text-color); display: inline; margin-top: 0; margin-left: 5px; }
        .input-group input[type="checkbox"] { vertical-align: middle; width: 17px; height: 17px; accent-color: var(--primary-color-action); }
        .input-group input[type="number"]:focus, .input-group select:focus { border-color: var(--primary-color-action); box-shadow: 0 0 0 0.2rem rgba(220,53,69,.25); outline: none; }
        .action-button { display: block; width: 100%; padding: 12px 15px; background-color: var(--primary-color-action); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 1.1em; font-weight: 500; transition: background-color 0.2s, transform 0.1s; margin-top: 25px; }
        .action-button:hover { background-color: var(--primary-hover-color-action); }
        .action-button:active { transform: translateY(1px); }
        .action-button:disabled { background-color: #adb5bd; cursor: not-allowed; }
        .results-summary { padding: 15px; background-color: #f8f9fa; border-radius: 6px; border: 1px solid var(--border-color); }
        .stat-group { margin-bottom: 15px; }
        .stat-group:last-child { margin-bottom: 0; }
        .stat-group h4 { font-size: 0.9em; color: var(--primary-color-action); margin-top:0; margin-bottom:8px; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid #e0e0e0; padding-bottom: 5px;}
        .stat-item { display: flex; justify-content: space-between; padding: 4px 0; font-size: 0.95em; margin-bottom: 2px; }
        .stat-label { color: var(--muted-text-color); flex-basis: 70%; text-align: left; padding-right: 10px; }
        .stat-value { color: var(--text-color); font-weight: 500; flex-basis: 30%; text-align: right; }
        #survivalGraphContainer { padding: 20px; background-color: #fdfdff; border: 1px solid var(--border-color); border-radius: 8px; box-shadow: 0 4px 12px var(--shadow-color); }
        #survivalGraphContainer h3 { margin-top: 0; margin-bottom: 20px; font-size: 1.2em; color: var(--text-color); font-weight: 500; text-align: center; }
        .graph-svg { display: block; margin: 0 auto; max-width: 100%; }
        .graph-axis.boundary-line, .graph-axis.tick-line { fill: none; stroke: var(--muted-text-color); stroke-width: 1px; shape-rendering: crispEdges; }
        .graph-grid-line { fill: none; stroke: var(--graph-internal-grid-color); stroke-width: 0.5px; shape-rendering: crispEdges; }
        .graph-axis text { font-size: 10px; fill: var(--muted-text-color); }
        .graph-line { fill: none; stroke-width: 2; }
        .graph-line.line1 { stroke: var(--graph-line1-color); }
        .graph-line.line2 { stroke: var(--graph-line2-color); }
        .graph-legend { font-size: 0.9em; margin-top: 15px; text-align: center;}
        .legend-item { display: inline-block; margin-right: 20px; }
        .legend-item:last-child { margin-right: 0; }
        .legend-color-box { display: inline-block; width: 12px; height: 12px; margin-right: 6px; vertical-align: middle; border-radius: 2px; }
        details { margin-top: 30px; border: 1px solid var(--border-color); border-radius: 8px; padding: 15px 20px; background-color: var(--surface-color); }
        summary { font-weight: 500; cursor: pointer; margin-bottom: 10px; color: var(--text-color); font-size: 1.05em; list-style: none; position: relative; padding-left: 25px; }
        summary::-webkit-details-marker { display: none; } 
        summary::before { content: '▶'; position: absolute; left: 0; font-size: 0.9em; transition: transform 0.2s ease-in-out; color: var(--muted-text-color); }
        details[open] summary::before { transform: rotate(90deg); }
        summary:hover { color: var(--primary-color-action); }
        .docs-content { font-size: 0.9em; line-height: 1.6; padding-top: 15px; border-top: 1px solid var(--border-color); color: var(--muted-text-color); }
        .docs-content h4 { margin-top: 15px; margin-bottom: 8px; border-bottom: 1px solid #e9ecef; padding-bottom: 5px; color: var(--text-color); font-size: 1em; font-weight: 500; }
        .docs-content h4:first-of-type { margin-top: 0; }
        .docs-content p, .docs-content ul, .docs-content ol { margin-bottom: 10px; }
        .docs-content ul, .docs-content ol { padding-left: 25px; }
        .docs-content li { margin-bottom: 5px; }
        .docs-content code { background-color: #e9ecef; padding: 2px 6px; border-radius: 4px; font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; font-size: 0.9em; color: #c82333; }
        @media (max-width: 820px) { .main-content { flex-direction: column; margin-bottom: 20px; } .input-panel, .output-panel { min-width: 100%; } .simulator-container { padding: 20px; } header h1 { font-size: 1.6em; margin-bottom: 20px; } .input-group label:not(input[type="checkbox"] + label) { flex: 1 1 100%; margin-bottom: 6px; padding-right: 0; } .input-group input[type="number"] { min-width: 100%; } .stat-item {flex-direction: column; align-items: flex-start; margin-bottom: 8px;} .stat-label {flex-basis: auto; margin-bottom: 2px;} .stat-value {flex-basis: auto; text-align: left;} }
    </style>
</head>
<body>
    <div class="simulator-container">
        <header><h1>Fire Storm Simulator</h1></header>
        <div class="main-content">
            <div class="input-panel">
                <h2>Unit & Scenario Configuration</h2>
                <div class="input-group">
                    <label for="unitMaxHp"><span class="main-label-text">Unit Max HP</span></label>
                    <input type="number" id="unitMaxHp" value="10" min="1">
                </div>
                <div class="input-group">
                    <label for="unitArmor"><span class="main-label-text">Unit Armor (Protection)</span></label>
                    <input type="number" id="unitArmor" value="0" min="0">
                </div>
                <div class="input-group">
                    <label for="unitFR"><span class="main-label-text">Unit Fire Resistance (FR)</span></label>
                    <input type="number" id="unitFR" value="0" min="-5">
                </div>
                <div class="input-group">
                    <label for="unitSize"><span class="main-label-text">Unit Size</span></label>
                    <input type="number" id="unitSize" value="3" min="1" max="10">
                </div>
                 <div class="input-group">
                    <label for="hpRegenPerTurn"><span class="main-label-text">HP Gained Per Turn</span><small>(Applied end of turn)</small></label>
                    <input type="number" id="hpRegenPerTurn" value="0" min="0" step="any">
                </div>
                <hr style="border: none; border-top: 1px dashed var(--border-color); margin: 20px 0;">
                <div class="input-group">
                    <label for="provinceTemperature"><span class="main-label-text">Province Temperature</span><small>(Cold -5 to Heat +5)</small></label>
                    <input type="number" id="provinceTemperature" value="0" min="-5" max="5" step="1">
                </div>
                <div class="checkbox-group">
                    <div class="input-group">
                        <input type="checkbox" id="isUnitEthereal">
                        <label for="isUnitEthereal">Unit is Ethereal? <small>(Cannot burn)</small></label>
                    </div>
                     <div class="input-group">
                        <input type="checkbox" id="isRaining">
                        <label for="isRaining">Is it Raining? <small>(Helps extinguish fire)</small></label>
                    </div>
                    <div class="input-group">
                        <input type="checkbox" id="hasLuck">
                        <label for="hasLuck">Luck? <small>(75% to nullify a killing strike's damage)</small></label>
                    </div>
                </div>
                <hr style="border: none; border-top: 1px dashed var(--border-color); margin: 20px 0;">
                <div class="input-group">
                    <label for="maxTurnsToSimulate"><span class="main-label-text">Max Turns to Simulate</span><small>(Per run, if unit survives)</small></label>
                    <input type="number" id="maxTurnsToSimulate" value="100" min="1">
                </div>
                <div class="input-group">
                    <label for="simulationRuns"><span class="main-label-text">Simulation Runs</span></label>
                    <input type="number" id="simulationRuns" value="10000" min="1">
                </div>
                <button class="action-button" onclick="startFireStormSimulation()">Run Simulation</button>
            </div>
            <div class="output-panel"> 
                <h2>Simulation Results</h2>
                <div id="results" class="results-summary"><p>Results will appear here after simulation.</p></div>
            </div>
        </div>
        <div id="survivalGraphContainer">
             <h3>Survival & Death Probability Over Time</h3>
             <svg id="survivalGraphSvg" class="graph-svg" width="100%" height="350"></svg> 
             <div class="graph-legend">
                <span class="legend-item"><span class="legend-color-box" style="background-color:var(--graph-line1-color);"></span>Dying in Turn X</span>
                <span class="legend-item"><span class="legend-color-box" style="background-color:var(--graph-line2-color);"></span>Cumulative Dead by Turn X</span>
             </div>
        </div>
        <details open>
            <summary>Documentation & How It Works (Fire Storm)</summary>
            <div class="docs-content">
                <h4>Purpose:</h4>
                <p>This tool simulates the impact of the Fire Storm battlefield enchantment on a single unit over multiple turns and simulation runs. It helps estimate survivability, the frequency of direct hits, the chances of catching fire, and the effects of burning, including the Luck mechanic.</p>
                <h4>How to Use (Inputs):</h4>
                <ul>
                    <li><strong>Unit Max HP:</strong> The starting and maximum Hit Points of the unit.</li>
                    <li><strong>Unit Armor (Protection):</strong> The unit's base armor value.</li>
                    <li><strong>Unit Fire Resistance (FR):</strong> The unit's Fire Resistance value. Can be negative.</li>
                    <li><strong>Unit Size:</strong> The size of the unit (1-10), used for burning damage.</li>
                    <li><strong>HP Gained Per Turn:</strong> HP regenerated at the end of each turn.</li>
                    <li><strong>Province Temperature:</strong> Cold -5 to Heat +5. Affects extinguishing.</li>
                    <li><strong>Unit is Ethereal?:</strong> If checked, cannot catch fire.</li>
                    <li><strong>Is it Raining?:</strong> If checked, helps extinguish fire.</li>
                    <li><strong>Luck?:</strong> If checked, unit has a 75% chance to nullify the damage from a Fire Storm hit or a burn tick that would otherwise be a killing blow. Does not prevent the "catch fire" chance from the initial hit.</li>
                    <li><strong>Max Turns to Simulate:</strong> Maximum turns per simulation run.</li>
                    <li><strong>Simulation Runs:</strong> Number of full simulation runs.</li>
                </ul>
                <h4>Mechanics Modeled:</h4>
                <ol>
                    <li><strong>Simulation Run vs. Turn:</strong> (Standard explanation)</li>
                    <li><strong>Fire Storm Event Timing:</strong> ~23.44 opportunities per turn.</li>
                    <li><strong>Chance for Unit to be Hit per Opportunity:</strong> 3%.</li>
                    <li><strong>Initial Damage Calculation (per Fire Storm Hit):</strong>
                        <ul>
                            <li>Base Damage Roll: <code>6 + DRN_1 - DRN_2</code> (fire damage). This value (before armor/FR) is also used as the base for the "catch fire" roll.</li>
                            <li>Armor Piercing (AP): Effective Protection = <code>floor(Unit_Armor / 2)</code>.</li>
                            <li>Damage after Armor: <code>Base_Damage_Roll - Effective_Protection</code>.</li>
                            <li><strong>Fire Resistance on Initial Hit (Two-Part):</strong>
                                <ol style="list-style-type: lower-alpha; padding-left: 20px;">
                                    <li>The damage remaining after armor is first reduced directly by <code>Unit_FR</code>.</li>
                                    <li>Then, an additional amount is subtracted: <code>Math.round(Unit_FR * 0.12)</code>.</li>
                                </ol>
                            </li>
                            <li>Final HP loss from hit: <code>max(0, Resulting_Damage_After_All_Reductions)</code>. This HP loss can be nullified by Luck if it's a killing blow.</li>
                        </ul>
                    </li>
                    <li><strong>Catching Fire (after a Fire Storm Hit):</strong>
                        <ul>
                            <li>Base for roll: Uses the <code>6 + DRN_1 - DRN_2</code> result *before* armor or the hit's FR mitigation.</li>
                            <li>Chance to Catch Fire = <code>max(0, Base_For_Roll) * 4%</code>.</li>
                            <li>Cannot catch fire if <code>Unit_FR >= 10</code> or Ethereal.</li>
                            <li>Luck does not prevent this roll, only the damage from the initial hit if applicable.</li>
                        </ul>
                    </li>
                    <li><strong>Burning Damage (at start of turn, if on fire):</strong>
                        <ul>
                            <li>Base: <code>ceil((roll d(Size))/2)</code>.</li>
                            <li>If <code>Unit_FR >= 5</code>, base burn damage is halved (floored).</li>
                            <li>Then, reduced directly by <code>Unit_FR</code>. Capped at 0.</li>
                            <li>This HP loss can be nullified by Luck if it's a killing blow.</li>
                        </ul>
                    </li>
                    <li><strong>Extinguishing Fire (at end of turn, if on fire):</strong> Standard Dominions mechanics (base chance, modified by FR, province temperature, and rain).</li>
                    <li><strong>HP Regeneration:</strong> Applied at the end of the turn, after all events. Cannot exceed Max HP. Fractional regeneration accumulates.</li>
                    <li><strong>Luck:</strong> If enabled, grants a 75% chance to negate the HP loss from any single instance of damage (direct Fire Storm hit or burn tick) that would reduce the unit's HP to 0 or less.</li>
                </ol>
                <h4>Output Statistics & Graph:</h4> (Standard explanation of survival/death stats, hit/burn stats, and graph lines)
                 <h4>Limitations:</h4> (Standard explanation: single unit, no morale, etc.)
            </div>
        </details>
    </div>
    <script>
        // Constants
        const FS_TICKS_PER_EVENT = 320;
        const FS_TICKS_PER_TURN = 7500;
        const FS_EVENTS_PER_TURN_RAW = FS_TICKS_PER_TURN / FS_TICKS_PER_EVENT;
        const FS_HIT_CHANCE_PER_OPPORTUNITY = 0.03;
        const FS_BASE_DAMAGE_COMPONENT = 6; 
        const FS_CATCH_FIRE_CHANCE_MULTIPLIER = 0.04;
        const FS_EXTINGUISH_BASE_CHANCE = 0.25;
        const FS_EXTINGUISH_MIN_CHANCE = 0.01; // Minimum chance to extinguish even with penalties
        const MAX_DRN_ITERATIONS = 20;
        const LUCK_CHANCE = 0.75; 

        function rollD6() { return Math.floor(Math.random() * 6) + 1; }
        function calculateDRN() { 
            let d1 = rollD6(), d2 = rollD6(), total = d1 + d2, iterations, currentDieVal;
            currentDieVal = d1; iterations = 0;
            while (currentDieVal === 6 && iterations < MAX_DRN_ITERATIONS) { total -= 1; currentDieVal = rollD6(); total += currentDieVal; iterations++; }
            currentDieVal = d2; iterations = 0;
            while (currentDieVal === 6 && iterations < MAX_DRN_ITERATIONS) { total -= 1; currentDieVal = rollD6(); total += currentDieVal; iterations++; }
            return total;
        }

        function calculateFireStormInitialDamageAndCatchFire(inputs, currentHp) {
            const rawDRNComponent = calculateDRN() - calculateDRN();
            const initialDamageRoll = FS_BASE_DAMAGE_COMPONENT + rawDRNComponent; 
            
            const damageValueForCatchFireRoll = Math.max(0, initialDamageRoll);

            const effectiveArmor = Math.floor(inputs.unitArmor / 2);
            let damageAfterArmor = initialDamageRoll - effectiveArmor;

            let damageAfterDirectFR = damageAfterArmor - inputs.unitFR;
            const percentageBasedReductionAmount = Math.round(inputs.unitFR * 0.02 * FS_BASE_DAMAGE_COMPONENT); // FR * 2% of base 6 = FR * 0.12
            
            let finalDamageToApplyPotential = Math.max(0, damageAfterDirectFR - percentageBasedReductionAmount);
            
            // This is the HP that would be lost from this hit, BEFORE Luck, capped by current HP.
            // This value is what Luck will check against if it's a killing blow.
            const potentialHpLostThisHit = Math.min(finalDamageToApplyPotential, currentHp); 
            
            let catchesFire = false;
            if (inputs.unitFR < 10 && !inputs.isUnitEthereal && damageValueForCatchFireRoll > 0) { 
                if (Math.random() < (damageValueForCatchFireRoll * FS_CATCH_FIRE_CHANCE_MULTIPLIER)) {
                    catchesFire = true;
                }
            }
            // hpLost returned is the *potential* HP loss before Luck is applied by the calling function.
            // The calling function will then apply Luck if necessary.
            return { hpLost: potentialHpLostThisHit, caughtFireThisHit: catchesFire, rawPotentialDamage: finalDamageToApplyPotential };
        }
        
        function simulateOneFullRun_FireStorm(inputs) {
            let currentHp = inputs.unitMaxHp;
            let turnsCompletedThisRun = 0; 
            let totalFireStormHits = 0; // Number of times Fire Storm *targets* the unit
            let totalInitialHPLostFromFireStorm = 0; // HP lost from direct FS hits, after Luck
            let sumOfNonLuckedFireStormDamagePotential = 0; // Sum of potential damage (after FR/armor) for hits that weren't Lucked
            let countOfNonLuckedFireStormHitsThatDidDamage = 0; // Count for the above sum

            let timesCaughtFireEvent = 0; 
            let totalBurningHPLost = 0;   // HP lost from burning, after Luck
            let turnsSpentOnFire = 0;      
            let died = false;
            let isOnFire = false; 
            let eventOpportunitiesAccumulator = 0;
            let hpRegenAccumulator = 0;
            let totalLuckSavesInRun = 0;

            for (let t = 0; t < inputs.maxTurns; t++) { 
                // --- Burning Damage (Start of Turn) ---
                if (isOnFire) {
                    turnsSpentOnFire++;
                    let burnDmgRoll = Math.floor(Math.random() * inputs.unitSize) + 1; // d(Size)
                    let baseBurnDmg = Math.ceil(burnDmgRoll / 2); // d(Size)/2, rounded up
                    if (inputs.unitFR >= 5) { baseBurnDmg = Math.floor(baseBurnDmg / 2); } // Halved if FR >= 5
                    const finalBurnDmgPotential = Math.max(0, baseBurnDmg - inputs.unitFR); // Then reduced by FR
                    
                    let actualBurnHpLoss = Math.min(finalBurnDmgPotential, currentHp);

                    if (inputs.hasLuck && currentHp > 0 && (currentHp - actualBurnHpLoss <= 0) && actualBurnHpLoss > 0) {
                        if (Math.random() < LUCK_CHANCE) {
                            actualBurnHpLoss = 0; // Damage nullified by Luck
                            totalLuckSavesInRun++;
                        }
                    }
                    currentHp -= actualBurnHpLoss;
                    totalBurningHPLost += actualBurnHpLoss;
                    if (currentHp <= 0) { died = true; turnsCompletedThisRun = t; break; }
                }

                // --- Fire Storm Hits (During Turn) ---
                eventOpportunitiesAccumulator += FS_EVENTS_PER_TURN_RAW;
                const eventsToProcessThisTurn = Math.floor(eventOpportunitiesAccumulator);
                eventOpportunitiesAccumulator -= eventsToProcessThisTurn;

                for (let i = 0; i < eventsToProcessThisTurn; i++) {
                    if (died) break; 
                    if (currentHp <= 0 && !died) { died = true; turnsCompletedThisRun = t; break; } 

                    if (Math.random() < FS_HIT_CHANCE_PER_OPPORTUNITY) {
                        totalFireStormHits++;
                        const hitOutcome = calculateFireStormInitialDamageAndCatchFire(inputs, currentHp);
                        let damageToApplyFromHit = hitOutcome.hpLost; // Potential HP lost from this hit, capped by current HP

                        let wasLucked = false;
                        if (inputs.hasLuck && currentHp > 0 && (currentHp - damageToApplyFromHit <= 0) && damageToApplyFromHit > 0) {
                            if (Math.random() < LUCK_CHANCE) {
                                damageToApplyFromHit = 0; // Damage nullified by Luck
                                totalLuckSavesInRun++;
                                wasLucked = true;
                            }
                        }
                        currentHp -= damageToApplyFromHit;
                        totalInitialHPLostFromFireStorm += damageToApplyFromHit;

                        if (!wasLucked && hitOutcome.rawPotentialDamage > 0) {
                            sumOfNonLuckedFireStormDamagePotential += hitOutcome.rawPotentialDamage;
                            countOfNonLuckedFireStormHitsThatDidDamage++;
                        }

                        if (currentHp <= 0) { died = true; turnsCompletedThisRun = t; break; }
                        
                        if (hitOutcome.caughtFireThisHit && !isOnFire) { 
                            isOnFire = true; 
                            timesCaughtFireEvent++; 
                        }
                    }
                }
                if (died) break; 

                // --- Extinguishing Fire (End of Turn) ---
                if (isOnFire) {
                    let extinguishChance = FS_EXTINGUISH_BASE_CHANCE + (inputs.unitFR * 0.01) + 
                                         ((inputs.provinceTemperature <= 0 ? Math.abs(inputs.provinceTemperature) : -inputs.provinceTemperature) * 0.05) +
                                         (inputs.isRaining ? 1.00 : 0); 
                    extinguishChance = Math.min(1.0, Math.max(FS_EXTINGUISH_MIN_CHANCE, extinguishChance));
                    if (Math.random() < extinguishChance) { isOnFire = false; }
                }

                // --- HP Regeneration (End of Turn) ---
                if (inputs.hpRegenPerTurnFloat > 0) {
                    hpRegenAccumulator += inputs.hpRegenPerTurnFloat;
                    const actualHpToRegen = Math.floor(hpRegenAccumulator);
                    if (actualHpToRegen > 0) {
                        currentHp += actualHpToRegen;
                        currentHp = Math.min(currentHp, inputs.unitMaxHp);
                        hpRegenAccumulator -= actualHpToRegen;
                    }
                }
                if (currentHp <= 0 && !died) { died = true; turnsCompletedThisRun = t; break;}
                turnsCompletedThisRun = t + 1;
            }
            return { 
                numTurnsCompleted: died ? turnsCompletedThisRun : inputs.maxTurns, 
                died: died, 
                turnOfDeath: died ? turnsCompletedThisRun : -1, 
                totalFireStormHits, 
                totalInitialHPLostFromFireStorm, 
                sumOfNonLuckedFireStormDamagePotential,
                countOfNonLuckedFireStormHitsThatDidDamage,
                timesCaughtFireEvent, 
                totalBurningHPLost, 
                turnsSpentOnFire,
                totalLuckSaves: totalLuckSavesInRun
            };
        }

        function startFireStormSimulation() {
            document.querySelectorAll('.input-panel input[type="number"], .input-panel select').forEach(input => input.style.borderColor = '');
            
            let isValid = true; 
            let errorMessages = [];
            const simInputs = {}; // Will be populated only if all inputs are valid

            // --- Phase 1: Validate all inputs ---
            const inputConfigs = [
                { id: 'unitMaxHp', parse: parseInt, min: 1, prettyName: "Unit Max HP" },
                { id: 'unitArmor', parse: parseInt, min: 0, prettyName: "Unit Armor" },
                { id: 'unitFR', parse: parseInt, min: -Infinity, prettyName: "Unit Fire Resistance" },
                { id: 'unitSize', parse: parseInt, min: 1, max: 10, prettyName: "Unit Size" },
                { id: 'hpRegenPerTurn', parse: parseFloat, min: 0, prettyName: "HP Gained Per Turn" },
                { id: 'provinceTemperature', parse: parseInt, min: -5, max: 5, prettyName: "Province Temperature" },
                { id: 'maxTurnsToSimulate', parse: parseInt, min: 1, prettyName: "Max Turns to Simulate" },
                { id: 'simulationRuns', parse: parseInt, min: 1, prettyName: "Simulation Runs" }
            ];

            inputConfigs.forEach(config => {
                const element = document.getElementById(config.id);
                if (!element) {
                    isValid = false; errorMessages.push(`DEV ERROR: Input element '${config.id}' not found in HTML.`); return;
                }
                const valueStr = element.value;
                const parsedValue = config.parse(valueStr);

                if (valueStr === "" || isNaN(parsedValue)) {
                    isValid = false; errorMessages.push(`${config.prettyName} must be a valid number.`); element.style.borderColor = 'red';
                } else {
                    if (config.min !== undefined && parsedValue < config.min) {
                        isValid = false; errorMessages.push(`${config.prettyName} must be >= ${config.min}.`); element.style.borderColor = 'red';
                    }
                    if (config.max !== undefined && parsedValue > config.max) {
                        isValid = false; errorMessages.push(`${config.prettyName} must be <= ${config.max}.`); element.style.borderColor = 'red';
                    }
                }
            });

            // Validate existence of checkbox elements
            if(!document.getElementById('isUnitEthereal')) { isValid = false; errorMessages.push("DEV ERROR: Checkbox 'isUnitEthereal' not found.");}
            if(!document.getElementById('isRaining')) { isValid = false; errorMessages.push("DEV ERROR: Checkbox 'isRaining' not found.");}
            if(!document.getElementById('hasLuck')) { isValid = false; errorMessages.push("DEV ERROR: Checkbox 'hasLuck' not found.");}

            const resultsDiv = document.getElementById('results'); 
            const svgGraphElement = document.getElementById('survivalGraphSvg');

            if (!isValid) { 
                resultsDiv.innerHTML = `<p style='color:red; padding: 10px;'>Input errors:<br>- ${errorMessages.join('<br>- ')}</p>`; 
                svgGraphElement.innerHTML = '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--muted-text-color)">Graph requires valid inputs.</text>'; 
                return; 
            }

            // --- Phase 2: If all valid, parse and store inputs ---
            simInputs.unitMaxHp = parseInt(document.getElementById('unitMaxHp').value);
            simInputs.unitArmor = parseInt(document.getElementById('unitArmor').value);
            simInputs.unitFR = parseInt(document.getElementById('unitFR').value);
            simInputs.unitSize = parseInt(document.getElementById('unitSize').value);
            simInputs.hpRegenPerTurnFloat = parseFloat(document.getElementById('hpRegenPerTurn').value);
            simInputs.provinceTemperature = parseInt(document.getElementById('provinceTemperature').value);
            simInputs.maxTurns = parseInt(document.getElementById('maxTurnsToSimulate').value);
            simInputs.numRuns = parseInt(document.getElementById('simulationRuns').value);
            simInputs.isUnitEthereal = document.getElementById('isUnitEthereal').checked;
            simInputs.isRaining = document.getElementById('isRaining').checked;
            simInputs.hasLuck = document.getElementById('hasLuck').checked;
            
            resultsDiv.innerHTML = "<p style='padding:10px;'>Running Fire Storm simulation, please wait...</p>"; 
            svgGraphElement.innerHTML = '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--muted-text-color)">Generating graph...</text>';
            document.querySelector('.action-button').disabled = true;
            
            setTimeout(() => {
                try {
                    let sumOfCompletedTurnsStat = 0; let deathCount = 0;
                    let totalFireStormHitsSum = 0; let totalInitialHPLostFromFireStormSum = 0;
                    let sumOfNonLuckedFireStormDamagePotentialOverall = 0;
                    let countOfNonLuckedFireStormHitsThatDidDamageOverall = 0;

                    let totalTimesCaughtFireEventSum = 0; let totalBurningHPLostSum = 0;
                    let totalTurnsSpentOnFireSum = 0;
                    let totalLuckSavesSum = 0; 
                    let deathsAtTurnT_array = new Array(simInputs.maxTurns).fill(0);
                    let allNumCompletedTurns = []; 
                    let runsWhereUnitCaughtFireAtLeastOnce = 0;

                    for (let i = 0; i < simInputs.numRuns; i++) {
                        const runResult = simulateOneFullRun_FireStorm(simInputs); 
                        allNumCompletedTurns.push(runResult.numTurnsCompleted);
                        sumOfCompletedTurnsStat += runResult.numTurnsCompleted;
                        if (runResult.died) { deathCount++; if (runResult.turnOfDeath >= 0 && runResult.turnOfDeath < simInputs.maxTurns) { deathsAtTurnT_array[runResult.turnOfDeath]++; }}
                        totalFireStormHitsSum += runResult.totalFireStormHits;
                        totalInitialHPLostFromFireStormSum += runResult.totalInitialHPLostFromFireStorm;
                        sumOfNonLuckedFireStormDamagePotentialOverall += runResult.sumOfNonLuckedFireStormDamagePotential;
                        countOfNonLuckedFireStormHitsThatDidDamageOverall += runResult.countOfNonLuckedFireStormHitsThatDidDamage;

                        if (runResult.timesCaughtFireEvent > 0) { runsWhereUnitCaughtFireAtLeastOnce++; }
                        totalTimesCaughtFireEventSum += runResult.timesCaughtFireEvent;
                        totalBurningHPLostSum += runResult.totalBurningHPLost;
                        totalTurnsSpentOnFireSum += runResult.turnsSpentOnFire;
                        totalLuckSavesSum += runResult.totalLuckSaves; 
                    }

                    const avgSurvivalLength = sumOfCompletedTurnsStat / simInputs.numRuns;
                    const deathPercentage = (deathCount / simInputs.numRuns) * 100;
                    let stdDevSurvivalLength = 0;
                    if (simInputs.numRuns > 1) { let sumSqDiff = allNumCompletedTurns.reduce((acc, len) => acc + Math.pow(len - avgSurvivalLength, 2), 0); stdDevSurvivalLength = Math.sqrt(sumSqDiff / simInputs.numRuns); }
                    const survivalPlus1Std = avgSurvivalLength + stdDevSurvivalLength; const survivalMinus1Std = Math.max(0, avgSurvivalLength - stdDevSurvivalLength);
                    const survivalPlus2Std = avgSurvivalLength + (2 * stdDevSurvivalLength); const survivalMinus2Std = Math.max(0, avgSurvivalLength - (2 * stdDevSurvivalLength));
                    
                    const avgHitsPerRun = totalFireStormHitsSum / simInputs.numRuns;
                    // Avg HP Lost per FS Hit now considers actual HP lost after luck.
                    // To get avg *potential* damage of non-lucked hits:
                    const avgPotentialDamagePerNonLuckedFSGroupingHit = countOfNonLuckedFireStormHitsThatDidDamageOverall > 0 ? sumOfNonLuckedFireStormDamagePotentialOverall / countOfNonLuckedFireStormHitsThatDidDamageOverall : 0;
                    
                    const percRunsUnitCaughtFire = (runsWhereUnitCaughtFireAtLeastOnce / simInputs.numRuns) * 100;
                    const avgTimesCaughtFire_IfEverCaught = runsWhereUnitCaughtFireAtLeastOnce > 0 ? totalTimesCaughtFireEventSum / runsWhereUnitCaughtFireAtLeastOnce : 0;
                    const avgBurningHPLost_IfEverCaught = runsWhereUnitCaughtFireAtLeastOnce > 0 ? totalBurningHPLostSum / runsWhereUnitCaughtFireAtLeastOnce : 0; 
                    const avgTurnsOnFire_IfEverCaught = runsWhereUnitCaughtFireAtLeastOnce > 0 ? totalTurnsSpentOnFireSum / runsWhereUnitCaughtFireAtLeastOnce : 0;
                    const avgLuckSavesPerRun = totalLuckSavesSum / simInputs.numRuns;

                    let outputHTML = `<div class="stat-group"><h4>Overall Statistics (per Run)</h4>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Total Runs:</span><span class="stat-value">${simInputs.numRuns}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Died in Runs:</span><span class="stat-value">${deathCount} (${deathPercentage.toFixed(1)}%)</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Survival (completed turns):</span><span class="stat-value">${avgSurvivalLength.toFixed(2)}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Std. Dev. of Survival:</span><span class="stat-value">${stdDevSurvivalLength.toFixed(2)}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">    ±1 Std Dev Range:</span><span class="stat-value">${survivalMinus1Std.toFixed(2)} - ${survivalPlus1Std.toFixed(2)}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">    ±2 Std Dev Range:</span><span class="stat-value">${survivalMinus2Std.toFixed(2)} - ${survivalPlus2Std.toFixed(2)}</span></div>`;
                    if (simInputs.hasLuck) {
                        outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Luck Saves (damage nullified):</span><span class="stat-value">${avgLuckSavesPerRun.toFixed(2)}</span></div>`;
                    }
                    outputHTML += `</div>`;

                    outputHTML += `<div class="stat-group"><h4>Fire Storm Hit Statistics</h4>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Fire Storm Hits / Run:</span><span class="stat-value">${avgHitsPerRun.toFixed(2)}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Potential Damage / Non-Lucked Grouping Hit:</span><span class="stat-value">${avgPotentialDamagePerNonLuckedFSGroupingHit.toFixed(2)}</span></div></div>`;
                    
                    outputHTML += `<div class="stat-group"><h4>Burning Statistics</h4>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Runs Unit Caught Fire:</span><span class="stat-value">${runsWhereUnitCaughtFireAtLeastOnce} (${percRunsUnitCaughtFire.toFixed(1)}%)</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Times Caught Fire (if ever caught):</span><span class="stat-value">${avgTimesCaughtFire_IfEverCaught.toFixed(2)}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Total Burning HP Lost (if ever caught):</span><span class="stat-value">${avgBurningHPLost_IfEverCaught.toFixed(2)}</span></div>`; // This is actual HP lost
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Turns Spent Burning (if ever caught):</span><span class="stat-value">${avgTurnsOnFire_IfEverCaught.toFixed(2)}</span></div></div>`;
                    resultsDiv.innerHTML = outputHTML;

                    let probDyingInTurnT_graphData = deathsAtTurnT_array.map(d => (d / simInputs.numRuns) * 100);
                    let cumulativeProbDeadByTurnT_graphData = [];
                    let cumulativeDeaths = 0;
                    for (let deathsInT of deathsAtTurnT_array) { cumulativeDeaths += deathsInT; cumulativeProbDeadByTurnT_graphData.push((cumulativeDeaths / simInputs.numRuns) * 100); }
                    drawSurvivalGraph(svgGraphElement, simInputs.maxTurns, probDyingInTurnT_graphData, cumulativeProbDeadByTurnT_graphData);
                } catch (error) { 
                    resultsDiv.innerHTML = `<p style="color:red; padding:10px;">Sim Error: ${error.message}</p><pre>${error.stack}</pre>`; 
                    svgGraphElement.innerHTML = `<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--muted-text-color)">Error generating graph.</text>`; 
                    console.error("Fire Storm Sim error:", error);
                } finally { 
                    document.querySelector('.action-button').disabled = false; 
                }
            }, 10);
        }
        function drawSurvivalGraph(svgElement, maxTurnsToGraph, probDyingInTurnT_data, cumulativeProbDeadByTurnT_data) {
            svgElement.innerHTML = ''; 
            const svgNS = "http://www.w3.org/2000/svg";
            const actualWidth = svgElement.parentElement.clientWidth; 
            svgElement.setAttribute('width', actualWidth);
            const height = parseInt(svgElement.getAttribute('height'));
            const margin = { top: 20, right: 30, bottom: 50, left: 60 };
            const graphWidth = actualWidth - margin.left - margin.right;
            const graphHeight = height - margin.top - margin.bottom;

            if (graphWidth <=0 || graphHeight <=0) { svgElement.innerHTML = '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--muted-text-color)">Not enough space for graph.</text>'; return; }
            const numDataPoints = maxTurnsToGraph;
            if (numDataPoints === 0) { svgElement.innerHTML = '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--muted-text-color)">No data for graph.</text>'; return;}

            const xScale = (turnIndex) => margin.left + (turnIndex / (numDataPoints > 1 ? numDataPoints - 1 : 1)) * graphWidth;
            const yScale = (percentage) => margin.top + graphHeight - (percentage / 100) * graphHeight;
            
            const gridGroup = document.createElementNS(svgNS, 'g'); 
            gridGroup.setAttribute('class', 'graph-grid'); 
            svgElement.appendChild(gridGroup);
            
            const xAxisLine = document.createElementNS(svgNS, 'line'); 
            xAxisLine.setAttributes({ x1: margin.left, y1: margin.top + graphHeight, x2: margin.left + graphWidth, y2: margin.top + graphHeight, class: 'graph-axis boundary-line' }); 
            svgElement.appendChild(xAxisLine);
            const yAxisLine = document.createElementNS(svgNS, 'line'); 
            yAxisLine.setAttributes({ x1: margin.left, y1: margin.top, x2: margin.left, y2: margin.top + graphHeight, class: 'graph-axis boundary-line' }); 
            svgElement.appendChild(yAxisLine);

            const numXTicks = Math.min(10, numDataPoints > 0 ? numDataPoints : 1);
            for (let i = 0; i <= numXTicks; i++) {
                const turnVal = numDataPoints > 1 ? Math.round(i * (numDataPoints - 1) / numXTicks) : (numDataPoints === 1 ? 0 : i) ;
                const x = xScale(turnVal);
                const tick = document.createElementNS(svgNS, 'line'); 
                tick.setAttributes({ x1: x, y1: margin.top + graphHeight, x2: x, y2: margin.top + graphHeight + 6, class: 'graph-axis tick-line' }); 
                svgElement.appendChild(tick);
                const label = document.createElementNS(svgNS, 'text'); 
                label.setAttributes({ x: x, y: margin.top + graphHeight + 20, 'text-anchor': 'middle', class: 'graph-axis' }); 
                label.textContent = turnVal; 
                svgElement.appendChild(label);
                if (Math.abs(x - margin.left) > 1e-6 && Math.abs(x - (margin.left + graphWidth)) > 1e-6) { 
                    const gridLine = document.createElementNS(svgNS, 'line'); 
                    gridLine.setAttributes({ x1: x, y1: margin.top, x2: x, y2: margin.top + graphHeight, class: 'graph-grid-line' }); 
                    gridGroup.appendChild(gridLine);
                }
            }
            const xAxisLabel = document.createElementNS(svgNS, 'text'); 
            xAxisLabel.setAttributes({x: margin.left + graphWidth/2, y: height - 10, 'text-anchor':'middle', class:'graph-axis', 'font-weight':'500'}); 
            xAxisLabel.textContent = "Turn Number"; 
            svgElement.appendChild(xAxisLabel);

            for (let i = 0; i <= 10; i++) { // Y-axis ticks at 10%
                const perc = i * 10; 
                const y = yScale(perc);
                const tick = document.createElementNS(svgNS, 'line'); 
                tick.setAttributes({ x1: margin.left - 6, y1: y, x2: margin.left, y2: y, class: 'graph-axis tick-line' }); 
                svgElement.appendChild(tick);
                const label = document.createElementNS(svgNS, 'text'); 
                label.setAttributes({ x: margin.left - 10, y: y, 'text-anchor': 'end', 'dominant-baseline': 'middle', class: 'graph-axis' }); 
                label.textContent = perc + '%'; 
                svgElement.appendChild(label);
                if (Math.abs(y - (margin.top + graphHeight)) > 1e-6 && Math.abs(y - margin.top) > 1e-6) {
                    const gridLine = document.createElementNS(svgNS, 'line'); 
                    gridLine.setAttributes({ x1: margin.left, y1: y, x2: margin.left + graphWidth, y2: y, class: 'graph-grid-line' }); 
                    gridGroup.appendChild(gridLine);
                }
            }
            
            const createPointsString = (data, xMap, yMap) => data.map((d, i) => `${xMap(i).toFixed(2)},${yMap(d).toFixed(2)}`).join(' ');
            if (probDyingInTurnT_data.length > 0) { 
                const polyline1 = document.createElementNS(svgNS, 'polyline'); 
                polyline1.setAttribute('points', createPointsString(probDyingInTurnT_data, xScale, yScale)); 
                polyline1.setAttribute('class', 'graph-line line1'); 
                svgElement.appendChild(polyline1); 
            }
            if (cumulativeProbDeadByTurnT_data.length > 0) { 
                const polyline2 = document.createElementNS(svgNS, 'polyline'); 
                polyline2.setAttribute('points', createPointsString(cumulativeProbDeadByTurnT_data, xScale, yScale)); 
                polyline2.setAttribute('class', 'graph-line line2'); 
                svgElement.appendChild(polyline2); 
            }
        }
        Element.prototype.setAttributes = function (attrs) { for (var key in attrs) this.setAttribute(key, attrs[key]); };
    </script>
</body>
</html>
