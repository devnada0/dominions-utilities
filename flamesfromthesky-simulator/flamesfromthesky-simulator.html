<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flames From the Sky Simulator - Dominions 6</title>
    <style>
        :root {
            --bg-color: #f4f6f9; 
            --surface-color: #ffffff;
            --text-color: #343a40; 
            --muted-text-color: #6c757d;
            --primary-color-action: #e74c3c; /* Fiery Red */
            --primary-hover-color-action: #c0392b; /* Darker Fiery Red */
            --border-color: #e9ecef;     
            --shadow-color: rgba(0,0,0,0.06);
            --font-family: "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
            
            --graph-line1-color: #e67e22; /* Orange */
            --graph-line2-color: #c0392b; /* Darker Red */
            --graph-axis-color: var(--muted-text-color);
            --graph-grid-color: #ced4da;
            --error-color: #dc3545;
        }
        body { 
            font-family: var(--font-family); 
            line-height: 1.6; 
            margin: 0; 
            background-color: var(--bg-color); 
            color: var(--text-color); 
            display: flex; 
            justify-content: center; 
            padding: 20px; 
            min-height: 100vh; 
            box-sizing: border-box; 
        }
        .simulator-container { 
            background-color: var(--surface-color); 
            padding: 30px; 
            border-radius: 12px; 
            box-shadow: 0 8px 25px var(--shadow-color); 
            width: 100%; 
            max-width: 980px; 
        }
        header h1 { 
            color: var(--text-color); 
            text-align: center; 
            margin-top: 0; 
            margin-bottom: 30px; 
            font-size: 1.8em; 
            font-weight: 600; 
            letter-spacing: -0.5px; 
        }
        .main-content { 
            display: flex; 
            flex-wrap: wrap; 
            gap: 30px; 
            margin-bottom: 30px; 
        }
        .input-panel, .output-panel { 
            flex: 1; 
            min-width: 340px; 
        }
        .input-panel { 
            padding: 25px; 
            background-color: #fcfdff; 
            border: 1px solid var(--border-color); 
            border-radius: 8px; 
        }
        .input-panel h2, .output-panel h2 { 
            margin-top: 0; 
            margin-bottom: 25px; 
            font-size: 1.3em; 
            color: var(--text-color); 
            border-bottom: 1px solid var(--border-color); 
            padding-bottom: 12px; 
            font-weight: 500; 
        }
        .input-group { 
            display: flex; 
            align-items: center; 
            margin-bottom: 15px; 
            flex-wrap: wrap; 
        }
        .input-group label { 
            flex: 0 0 190px; 
            margin-bottom: 0; 
            font-weight: 500; 
            font-size: 0.9em; 
            color: var(--muted-text-color); 
            padding-right: 10px; 
            box-sizing: border-box; 
            line-height: 1.3; 
        }
        .input-group label .main-label-text { 
            color: var(--text-color); 
            display: block; 
            font-weight: 500; 
            font-size: 0.95em;
        }
        .input-group label small { 
            display: block; 
            font-size: 0.8em; 
            font-weight: normal; 
            line-height: 1.2; 
            color: #88929b; 
            margin-top: 2px; 
        }
        .checkbox-group { margin-bottom: 15px; padding-top: 10px; border-top: 1px dashed var(--border-color); }
        .checkbox-group .input-group, .sub-input-group { display: block; margin-bottom: 8px; }
        .sub-input-group { margin-left: 25px; margin-top: 5px; margin-bottom:10px; }
        .sub-input-group label { font-size: 0.85em; flex-basis: auto; margin-bottom:3px; }
        .sub-input-group input[type="text"] { width: calc(100% - 24px); font-size: 0.9em; padding: 6px 10px;}

        .input-group input[type="number"], .input-group select { 
            flex: 1; 
            min-width: 80px; 
            padding: 9px 12px; 
            box-sizing: border-box; 
            border: 1px solid #ced4da; 
            border-radius: 6px; 
            font-size: 0.95em; 
            transition: border-color 0.2s, box-shadow 0.2s; 
        }
        .input-group input[type="checkbox"] + label { 
            display: inline-flex; 
            align-items:center; 
            margin-left: 8px; 
            font-weight: normal; 
            font-size: 0.95em; 
            color: var(--text-color); 
            vertical-align: middle; 
            cursor: pointer; 
        }
        .input-group input[type="checkbox"] { 
            vertical-align: middle; 
            width: 17px; 
            height: 17px; 
            accent-color: var(--primary-color-action); 
        }
        .input-group input[type="number"]:focus, .input-group select:focus, .input-group input[type="text"]:focus { 
            border-color: var(--primary-color-action); 
            box-shadow: 0 0 0 0.2rem rgba(231,76,60,.25); 
            outline: none; 
        }
        .input-group input.error {
            border-color: var(--error-color);
        }
        .error-message-box {
            color: var(--error-color);
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 15px;
        }
        .action-button { 
            display: block; 
            width: 100%; 
            padding: 12px 15px; 
            background-color: var(--primary-color-action); 
            color: white; 
            border: none; 
            border-radius: 6px; 
            cursor: pointer; 
            font-size: 1.1em; 
            font-weight: 500; 
            transition: background-color 0.2s, transform 0.1s; 
            margin-top: 25px; 
        }
        .action-button:hover { background-color: var(--primary-hover-color-action); }
        .action-button:active { transform: translateY(1px); }
        .action-button:disabled { background-color: #adb5bd; cursor: not-allowed; }
        
        .results-summary { padding: 15px; background-color: #f8f9fa; border-radius: 6px; border: 1px solid var(--border-color); }
        .stat-group { margin-bottom: 15px; }
        .stat-group:last-child { margin-bottom: 0; }
        .stat-group h4 { 
            font-size: 0.9em; 
            color: var(--primary-color-action); 
            margin-top:0; 
            margin-bottom:8px; 
            text-transform: uppercase; 
            letter-spacing: 0.5px; 
            border-bottom: 1px solid #e0e0e0; 
            padding-bottom: 5px;
        }
        .stat-item { 
            display: flex; 
            justify-content: space-between; 
            padding: 4px 0; 
            font-size: 0.95em; 
            margin-bottom: 2px; 
        }
        .stat-label { 
            color: var(--muted-text-color); 
            flex-basis: 70%; 
            text-align: left; 
            padding-right: 10px; 
        }
        .stat-value { 
            color: var(--text-color); 
            font-weight: 500; 
            flex-basis: 30%; 
            text-align: right; 
        }
        
        #deathGraphContainer { 
            padding: 20px; 
            background-color: #fdfdff; 
            border: 1px solid var(--border-color); 
            border-radius: 8px; 
            box-shadow: 0 4px 12px var(--shadow-color); 
        }
        #deathGraphContainer h3 { 
            margin-top: 0; 
            margin-bottom: 20px; 
            font-size: 1.2em; 
            color: var(--text-color); 
            font-weight: 500; 
            text-align: center; 
        }
        .graph-svg { display: block; margin: 0 auto; max-width: 100%; }
        .graph-axis.boundary-line, .graph-axis.tick-line { 
            fill: none; 
            stroke: var(--graph-axis-color); 
            stroke-width: 1px; 
            shape-rendering: crispEdges; 
        }
        .graph-grid-line { 
            fill: none; 
            stroke: var(--graph-grid-color); 
            stroke-width: 0.5px; 
            shape-rendering: crispEdges; 
        }
        .graph-axis text { font-size: 10px; fill: var(--graph-axis-color); }
        .graph-line { fill: none; stroke-width: 2; }
        .graph-line.line1 { stroke: var(--graph-line1-color); }
        .graph-line.line2 { stroke: var(--graph-line2-color); }
        .graph-legend { font-size: 0.9em; margin-top: 15px; text-align: center;}
        .legend-item { display: inline-block; margin-right: 20px; }
        .legend-item:last-child { margin-right: 0; }
        .legend-color-box { 
            display: inline-block; 
            width: 12px; 
            height: 12px; 
            margin-right: 6px; 
            vertical-align: middle; 
            border-radius: 2px; 
        }
        
        details { 
            margin-top: 30px; 
            border: 1px solid var(--border-color); 
            border-radius: 8px; 
            padding: 15px 20px; 
            background-color: var(--surface-color); 
        }
        summary { 
            font-weight: 500; 
            cursor: pointer; 
            margin-bottom: 10px; 
            color: var(--text-color); 
            font-size: 1.05em; 
            list-style: none; 
            position: relative; 
            padding-left: 25px; 
        }
        summary::-webkit-details-marker { display: none; } 
        summary::before { 
            content: 'â–¶'; 
            position: absolute; 
            left: 0; 
            font-size: 0.9em; 
            transition: transform 0.2s ease-in-out; 
            color: var(--muted-text-color); 
        }
        details[open] summary::before { transform: rotate(90deg); }
        summary:hover { color: var(--primary-color-action); }
        .docs-content { 
            font-size: 0.9em; 
            line-height: 1.6; 
            padding-top: 15px; 
            border-top: 1px solid var(--border-color); 
            color: var(--muted-text-color); 
        }
        .docs-content h4 { 
            margin-top: 15px; 
            margin-bottom: 8px; 
            border-bottom: 1px solid #e9ecef; 
            padding-bottom: 5px; 
            color: var(--text-color); 
            font-size: 1em; 
            font-weight: 500; 
        }
        .docs-content h4:first-of-type { margin-top: 0; }
        .docs-content p, .docs-content ul, .docs-content ol { margin-bottom: 10px; }
        .docs-content ul, .docs-content ol { padding-left: 25px; }
        .docs-content li { margin-bottom: 5px; }
        .docs-content code { 
            background-color: #e9ecef; 
            padding: 2px 6px; 
            border-radius: 4px; 
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; 
            font-size: 0.9em; 
            color: var(--primary-color-action); 
        }
        .hidden { display: none !important; }
        @media (max-width: 820px) { 
            .main-content { flex-direction: column; margin-bottom: 20px; } 
            .input-panel, .output-panel { min-width: 100%; } 
            .simulator-container { padding: 20px; } 
            header h1 { font-size: 1.6em; margin-bottom: 20px; } 
            .input-group label:not(input[type="checkbox"] + label) { flex: 1 1 100%; margin-bottom: 6px; padding-right: 0; } 
            .input-group input[type="number"] { min-width: 100%; } 
            .stat-item {flex-direction: column; align-items: flex-start; margin-bottom: 8px;} 
            .stat-label {flex-basis: auto; margin-bottom: 2px;} 
            .stat-value {flex-basis: auto; text-align: left;} 
        }
    </style>
</head>
<body>
    <div class="simulator-container">
        <header><h1>Flames From the Sky Simulator</h1></header>
        <div class="main-content">
            <div class="input-panel">
                <h2>Unit & Scenario Configuration</h2>
                <div class="input-group">
                    <label for="unitMaxHp"><span class="main-label-text">Unit Max HP</span></label>
                    <input type="number" id="unitMaxHp" value="10" min="1">
                </div>
                <div class="input-group">
                    <label for="unitProt"><span class="main-label-text">Unit Protection</span></label>
                    <input type="number" id="unitProt" value="0" min="0">
                </div>
                <div class="input-group">
                    <label for="unitFR"><span class="main-label-text">Unit Fire Resistance</span></label>
                    <input type="number" id="unitFR" value="0">
                </div>
                <div class="input-group">
                    <label for="unitSize"><span class="main-label-text">Unit Size</span><small>(For burning damage)</small></label>
                    <input type="number" id="unitSize" value="3" min="1" max="10">
                </div>
                 <div class="input-group">
                    <label for="hpRegenPerTurn"><span class="main-label-text">HP Gained Per Turn</span><small>(Applied end of turn)</small></label>
                    <input type="number" id="hpRegenPerTurn" value="0" min="0" step="any">
                </div>
                <hr style="border: none; border-top: 1px dashed var(--border-color); margin: 20px 0;">
                <div class="input-group">
                    <label for="numBarrages"><span class="main-label-text">Number of Barrages</span><small>(Spell casts)</small></label>
                    <input type="number" id="numBarrages" value="1" min="1">
                </div>
                <div class="input-group">
                    <label for="fireballsPerBarrage"><span class="main-label-text">Fireballs per Barrage</span></label>
                    <input type="number" id="fireballsPerBarrage" value="493" min="1">
                </div>
                <hr style="border: none; border-top: 1px dashed var(--border-color); margin: 20px 0;">
                <div class="input-group">
                    <label for="provinceTemperature"><span class="main-label-text">Province Temperature</span><small>(Cold -5 to Heat +5)</small></label>
                    <input type="number" id="provinceTemperature" value="0" min="-5" max="5" step="1">
                </div>
                <div class="checkbox-group">
                    <div class="input-group">
                        <input type="checkbox" id="isUnitEthereal">
                        <label for="isUnitEthereal">Unit is Ethereal? <small>(Cannot burn)</small></label>
                    </div>
                     <div class="input-group">
                        <input type="checkbox" id="twistOfFateActive">
                        <label for="twistOfFateActive">Twist of Fate Active?</label>
                    </div>
                    <div class="sub-input-group hidden" id="twistOfFateTurnsGroup">
                        <label for="twistOfFateCastTurns"><span class="main-label-text">Twist of Fate Cast Turn(s)</span><small>e.g., 1, 3-5, 7</small></label>
                        <input type="text" id="twistOfFateCastTurns" value="1">
                    </div>
                </div>
                <hr style="border: none; border-top: 1px dashed var(--border-color); margin: 20px 0;">
                <div class="input-group">
                    <label for="simulationRuns"><span class="main-label-text">Simulation Runs</span></label>
                    <input type="number" id="simulationRuns" value="10000" min="1" max="1000000">
                </div>
                <button class="action-button" id="runSimulationButton">Run Simulation</button>
            </div>
            <div class="output-panel"> 
                <h2>Simulation Results</h2>
                <div id="errorMessages" class="error-message-box" style="display:none;"></div>
                <div id="resultsSummary" class="results-summary"><p>Results will appear here after simulation.</p></div>
            </div>
        </div>
        <div id="deathGraphContainer">
             <h3>Death Probability Over Time</h3>
             <svg id="deathGraphSvg" class="graph-svg" width="100%" height="350"></svg> 
             <div class="graph-legend">
                <span class="legend-item"><span class="legend-color-box" style="background-color:var(--graph-line1-color);"></span>Dying in Turn X (%)</span>
                <span class="legend-item"><span class="legend-color-box" style="background-color:var(--graph-line2-color);"></span>Cumulative Dead by Turn X (%)</span>
             </div>
        </div>
        <details open>
            <summary>Documentation & How It Works</summary>
            <div class="docs-content">
                <h4>Purpose:</h4>
                <p>This tool simulates the damage taken by a single, randomly placed unit from one or more "Flames From the Sky" spell castings in Dominions 6. It models initial fireball impacts (Armor Piercing, DRN-based), subsequent burning, Twist of Fate, extinguishing, and HP regeneration over a series of game turns to estimate unit survivability.</p>
                
                <h4>How to Use (Inputs):</h4>
                <ul>
                    <li><strong>Unit Max HP:</strong> The starting and maximum Hit Points of the unit.</li>
                    <li><strong>Unit Protection:</strong> The unit's base armor value. This will be halved for initial fireball damage (Armor Piercing).</li>
                    <li><strong>Unit Fire Resistance (FR):</strong> The unit's Fire Resistance value.</li>
                    <li><strong>Unit Size:</strong> The size of the unit, used for calculating burning damage.</li>
                    <li><strong>HP Gained Per Turn:</strong> Amount of HP the unit regenerates at the end of each full turn.</li>
                    <li><strong>Number of Barrages:</strong> How many times the Flames From the Sky spell is cast. Each barrage lasts 3 game turns.</li>
                    <li><strong>Fireballs per Barrage:</strong> Total number of fireballs released by a single barrage spell.</li>
                    <li><strong>Province Temperature:</strong> The temperature scale of the province (Cold -5 to Heat +5).</li>
                    <li><strong>Unit is Ethereal?:</strong> If checked, the unit cannot catch fire.</li>
                    <li><strong>Twist of Fate Active?:</strong> If checked, enables Twist of Fate mechanic.
                        <ul><li><strong>Twist of Fate Cast Turn(s):</strong> Comma-separated list of turns or ranges (e.g., "1, 3, 5-7") on which Twist of Fate is cast, granting one charge to nullify the next instance of damage. A charge persists until used.</li></ul>
                    </li>
                    <li><strong>SimulationRuns:</strong> Number of times to run the full simulation. (Min: 1)</li>
                </ul>

                <h4>Mechanics Modeled (per Simulation Run):</h4>
                <ol>
                    <li><strong>Unit Placement:</strong> Randomly placed on a 50x100 grid.</li>
                    <li><strong>Turn Structure:</strong> Barrages over 3 turns each, then 20 aftermath turns.</li>
                    <li><strong>Twist of Fate (ToF):</strong>
                        <ul>
                            <li>If ToF is active and the current game turn is a specified cast turn, the unit gains/refreshes one ToF charge.</li>
                            <li>If the unit has a ToF charge and is about to take positive damage (from fireball or burn), the damage is nullified, and the charge is consumed. One charge per instance of damage.</li>
                        </ul>
                    </li>
                    <li><strong>Order of Events within a Game Turn (after ToF check for new charge):</strong>
                        <ol style="list-style-type: lower-alpha;">
                            <li><strong>Burning Damage:</strong> (Standard logic, ToF can block this).</li>
                            <li><strong>Fireball Impacts:</strong> If the current game turn is part of an active barrage:
                                <ul>
                                    <li><code>DamagePreDefenses</code>: For center hits <code>max(0, 24 + DRN() - DRN())</code>, for splash hits <code>max(0, 16 + DRN() - DRN())</code>. (DRN is 2d6 open-ended).</li>
                                    <li><strong>Fire Resistance (FR) on Initial Hit (applied to <code>DamagePreDefenses</code>):</strong>
                                        <ol style="list-style-type: roman; padding-left: 20px;">
                                            <li>Direct Subtraction: <code>Damage_Stage1 = DamagePreDefenses - UnitFR</code>.</li>
                                            <li>Percentage Reduction: An additional amount, <code>Math.round(UnitFR * 0.02 * Nominal_Base)</code>, is subtracted from <code>Damage_Stage1</code>. (<code>Nominal_Base</code> is the spell's fixed base component: 24 for center, 16 for splash, *not* the DRN-modified value).</li>
                                        </ol>
                                    </li>
                                    <li><strong>Protection (Prot) - Armor Piercing:</strong> Effective Protection = <code>floor(Unit Protection / 2)</code>. <code>Net Damage = max(0, Damage_After_All_FR - Effective_Protection)</code>.</li>
                                    <li>Twist of Fate can block an individual fireball hit (the <code>Net Damage</code>).</li>
                                    <li>Catch fire chance is based on <code>DamagePreDefenses</code> (before any FR/Prot is applied).</li>
                                </ul>
                            </li>
                            <li><strong>Extinguishing Fire & HP Regeneration:</strong> (Standard logic).</li>
                        </ol>
                    </li>
                </ol>

                <h4>Output Statistics & Graph:</h4>
                 <ul>
                    <li><strong>Overall Statistics:</strong> Percentage of runs where unit died, average turn of death.</li>
                    <li><strong>Damage Statistics:</strong>
                        <ul>
                            <li>Avg. Initial Fireball Damage (if hit by any fireball).</li>
                            <li>Probability of Taking Initial Fireball Damage (%).</li>
                            <li>Avg. Center Hits / Run.</li>
                            <li>Avg. Splash Hits / Run.</li>
                            <li>Avg. Burn Damage / Run.</li>
                            <li>Avg. Instances of Damage Nullified by Twist of Fate / Run (if active).</li>
                        </ul>
                    </li>
                    <li><strong>Fire Status Statistics:</strong> Percentage of runs unit caught fire, average times caught fire, average turns spent burning if ever caught.</li>
                    <li><strong>Graph - Death Probability Over Time:</strong> Y-axis labels are percentages.
                        <ul>
                            <li>Line 1 (Orange): Percentage of simulation runs where the unit died in that specific game turn.</li>
                            <li>Line 2 (Red): Cumulative percentage of simulation runs where the unit was dead by the end of that specific game turn.</li>
                        </ul>
                    </li>
                </ul>
                <h4>Limitations:</h4>
                <ul>
                    <li>(Standard limitations, plus ToF assumptions: one charge max, persists till used, refreshes on cast turn).</li>
                </ul>
            </div>
        </details>
    </div>

    <script>
        // Constants
        const MAP_WIDTH = 50;
        const MAP_HEIGHT = 100;
        const CENTER_DAMAGE_NOMINAL_BASE = 24; 
        const SPLASH_DAMAGE_NOMINAL_BASE = 16; 
        const BARRAGE_DURATION_TURNS = 3; 
        const AFTERMATH_DURATION_TURNS = 20; 
        
        const CATCH_FIRE_CHANCE_MULTIPLIER = 0.04;
        const EXTINGUISH_BASE_CHANCE = 0.25;
        const EXTINGUISH_MIN_CHANCE = 0.01;
        const MAX_DRN_ITERATIONS = 20;


        Element.prototype.setAttributes = function (attrs) { 
            for (var key in attrs) this.setAttribute(key, attrs[key]); 
        };

        function rollD6() { return Math.floor(Math.random() * 6) + 1; }
        
        function calculateDRN() { 
            let d1 = rollD6(), d2 = rollD6(), total = d1 + d2, iterations, currentDieVal;
            currentDieVal = d1; iterations = 0;
            while (currentDieVal === 6 && iterations < MAX_DRN_ITERATIONS) { total -= 1; currentDieVal = rollD6(); total += currentDieVal; iterations++; }
            currentDieVal = d2; iterations = 0;
            while (currentDieVal === 6 && iterations < MAX_DRN_ITERATIONS) { total -= 1; currentDieVal = rollD6(); total += currentDieVal; iterations++; }
            return total;
        }

        function parseTurnInput(turnString) {
            if (!turnString || turnString.trim() === "") return [];
            const turns = new Set();
            const parts = turnString.split(',');
            for (const part of parts) {
                const trimmedPart = part.trim();
                if (trimmedPart.includes('-')) {
                    const range = trimmedPart.split('-');
                    if (range.length === 2) {
                        const start = parseInt(range[0]);
                        const end = parseInt(range[1]);
                        if (!isNaN(start) && !isNaN(end) && start > 0 && end >= start) {
                            for (let i = start; i <= end; i++) {
                                turns.add(i);
                            }
                        } else { return null; } 
                    } else { return null; } 
                } else {
                    const turn = parseInt(trimmedPart);
                    if (!isNaN(turn) && turn > 0) {
                        turns.add(turn);
                    } else { return null; } 
                }
            }
            return Array.from(turns).sort((a, b) => a - b);
        }


        // --- Core Simulation Logic ---
        function applyArmorPiercingFireballDamage(damagePreDefenses, nominalBaseOfHit, unitFullProt, unitFR) {
            const effectiveProt = Math.floor(unitFullProt / 2); 
            
            let damageAfterDirectFR = damagePreDefenses - unitFR;
            const percentageBasedReductionAmount = Math.round(unitFR * 0.02 * nominalBaseOfHit); 
            let damageAfterAllFR = Math.max(0, damageAfterDirectFR - percentageBasedReductionAmount);
            
            return Math.max(0, damageAfterAllFR - effectiveProt);
        }

        function simulateOneFullRun(inputs) {
            let currentHp = inputs.unitMaxHp;
            let isOnFire = false;
            let totalInitialDamageTakenThisRun = 0;
            let totalBurnDamageTakenThisRun = 0;
            let timesCaughtFireThisRun = 0;
            let turnsSpentBurningThisRun = 0;
            let centerHitsThisRun = 0;
            let splashHitsThisRun = 0;
            let died = false;
            let turnOfDeath = -1;
            let twistOfFateCharges = 0;
            let twistOfFateDamageNullifiedThisRun = 0;

            const unitTargetX = Math.floor(Math.random() * MAP_WIDTH) + 1;
            const unitTargetY = Math.floor(Math.random() * MAP_HEIGHT) + 1;

            const totalBarrageEffectTurns = inputs.numBarrages * BARRAGE_DURATION_TURNS;
            const totalTurnsToSimulate = totalBarrageEffectTurns + AFTERMATH_DURATION_TURNS;
            
            let fireballsForBarrageTurns = [];
            if (inputs.fireballsPerBarrage > 0 && inputs.numBarrages > 0) {
                const baseFireballsPerSubTurn = Math.floor(inputs.fireballsPerBarrage / BARRAGE_DURATION_TURNS);
                let totalRemainderFireballs = inputs.fireballsPerBarrage % BARRAGE_DURATION_TURNS; 
                
                for (let b = 0; b < inputs.numBarrages; b++) {
                    let currentBarrageRemainder = totalRemainderFireballs; 
                    for (let t = 0; t < BARRAGE_DURATION_TURNS; t++) {
                        let count = baseFireballsPerSubTurn;
                        if (currentBarrageRemainder > 0) {
                            count++;
                            currentBarrageRemainder--;
                        }
                        fireballsForBarrageTurns.push(count);
                    }
                }
            }
            
            let hpRegenAccumulator = 0;

            for (let gameTurn = 1; gameTurn <= totalTurnsToSimulate; gameTurn++) {
                if (died) break; 

                if (inputs.twistOfFateActive && inputs.parsedTwistOfFateCastTurns.includes(gameTurn)) {
                    twistOfFateCharges = 1; 
                }

                if (isOnFire) {
                    turnsSpentBurningThisRun++; 
                    let burnRoll = Math.floor(Math.random() * inputs.unitSize) + 1; 
                    let baseBurnDmg = Math.ceil(burnRoll / 2);
                    if (inputs.unitFR >= 5) {
                        baseBurnDmg = Math.floor(baseBurnDmg / 2);
                    }
                    let finalBurnDmg = Math.max(0, baseBurnDmg - inputs.unitFR);
                    
                    if (finalBurnDmg > 0 && twistOfFateCharges > 0) {
                        finalBurnDmg = 0;
                        twistOfFateCharges--;
                        twistOfFateDamageNullifiedThisRun++;
                    }

                    currentHp -= finalBurnDmg;
                    totalBurnDamageTakenThisRun += finalBurnDmg;

                    if (currentHp <= 0) {
                        died = true;
                        turnOfDeath = gameTurn;
                        continue;  
                    }
                }

                const currentBarragePhaseTurnIndex = gameTurn - 1; 
                if (currentBarragePhaseTurnIndex < fireballsForBarrageTurns.length) {
                    const numFireballsThisTurn = fireballsForBarrageTurns[currentBarragePhaseTurnIndex];
                    for (let f = 0; f < numFireballsThisTurn; f++) {
                        const fireballImpactX = Math.floor(Math.random() * MAP_WIDTH) + 1;
                        const fireballImpactY = Math.floor(Math.random() * MAP_HEIGHT) + 1;
                        
                        let nominalBaseForHitType = 0; 
                        let wasCenterHitThisFireball = false;

                        if (fireballImpactX === unitTargetX && fireballImpactY === unitTargetY) {
                            nominalBaseForHitType = CENTER_DAMAGE_NOMINAL_BASE;
                            wasCenterHitThisFireball = true;
                        } else { 
                            for (let dx = -1; dx <= 1; dx++) {
                                for (let dy = -1; dy <= 1; dy++) {
                                    if (dx === 0 && dy === 0) continue; 
                                    if (fireballImpactX + dx === unitTargetX && fireballImpactY + dy === unitTargetY) {
                                        nominalBaseForHitType = SPLASH_DAMAGE_NOMINAL_BASE;
                                        break; 
                                    }
                                }
                                if (nominalBaseForHitType > 0 && !wasCenterHitThisFireball) break; 
                            }
                        }

                        if (nominalBaseForHitType > 0) { 
                            const damagePreDefenses = Math.max(0, nominalBaseForHitType + calculateDRN() - calculateDRN());

                            if (wasCenterHitThisFireball) centerHitsThisRun++; else splashHitsThisRun++;

                            let potentialNetDamage = applyArmorPiercingFireballDamage(damagePreDefenses, nominalBaseForHitType, inputs.unitProt, inputs.unitFR);
                            let actualNetDamage = potentialNetDamage;
                            
                            if (potentialNetDamage > 0 && twistOfFateCharges > 0) {
                                actualNetDamage = 0;
                                twistOfFateCharges--;
                                twistOfFateDamageNullifiedThisRun++;
                            }

                            currentHp -= actualNetDamage;
                            totalInitialDamageTakenThisRun += actualNetDamage; 

                            if (currentHp <= 0) {
                                died = true;
                                turnOfDeath = gameTurn;
                            }
                            
                            if (damagePreDefenses > 0) { 
                                if (!isOnFire && inputs.unitFR < 10 && !inputs.isUnitEthereal) {
                                    if (Math.random() < (damagePreDefenses * CATCH_FIRE_CHANCE_MULTIPLIER)) {
                                        isOnFire = true;
                                        timesCaughtFireThisRun++;
                                    }
                                }
                            }
                        }
                        if (died) break; 
                    } 
                } 
                if (died) continue; 

                if (isOnFire) {
                    let extinguishChance = EXTINGUISH_BASE_CHANCE +
                                         (inputs.unitFR * 0.01) +
                                         ((0 - inputs.provinceTemperature) * 0.05); 
                    extinguishChance = Math.min(1.0, Math.max(EXTINGUISH_MIN_CHANCE, extinguishChance));
                    if (Math.random() < extinguishChance) {
                        isOnFire = false;
                    }
                }

                if (inputs.hpRegenPerTurn > 0) {
                    hpRegenAccumulator += inputs.hpRegenPerTurn;
                    const actualHpToRegen = Math.floor(hpRegenAccumulator);
                    if (actualHpToRegen > 0) {
                        currentHp = Math.min(inputs.unitMaxHp, currentHp + actualHpToRegen);
                        hpRegenAccumulator -= actualHpToRegen;
                    }
                }
            } 

            return {
                died: died,
                turnOfDeath: died ? turnOfDeath : -1,
                totalTurnsSurvived: died ? turnOfDeath : totalTurnsToSimulate,
                totalInitialDamage: totalInitialDamageTakenThisRun,
                totalBurnDamage: totalBurnDamageTakenThisRun,
                timesCaughtFire: timesCaughtFireThisRun,
                turnsSpentBurning: turnsSpentBurningThisRun,
                centerHits: centerHitsThisRun,
                splashHits: splashHitsThisRun,
                tofNullified: twistOfFateDamageNullifiedThisRun
            };
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('runSimulationButton').addEventListener('click', startFullSimulation);
            const tofCheckbox = document.getElementById('twistOfFateActive');
            const tofTurnsGroup = document.getElementById('twistOfFateTurnsGroup');
            tofCheckbox.addEventListener('change', () => {
                tofTurnsGroup.classList.toggle('hidden', !tofCheckbox.checked);
            });
        });

        function validateInputs(inputs) {
            const errors = [];
            const inputConfigs = [
                { id: 'unitMaxHp', parse: parseInt, min: 1, prettyName: "Unit Max HP" },
                { id: 'unitProt', parse: parseInt, min: 0, prettyName: "Unit Protection" },
                { id: 'unitFR', parse: parseInt, prettyName: "Unit Fire Resistance" }, 
                { id: 'unitSize', parse: parseInt, min: 1, max: 10, prettyName: "Unit Size" },
                { id: 'hpRegenPerTurn', parse: parseFloat, min: 0, prettyName: "HP Gained Per Turn" },
                { id: 'numBarrages', parse: parseInt, min: 1, prettyName: "Number of Barrages" },
                { id: 'fireballsPerBarrage', parse: parseInt, min: 1, prettyName: "Fireballs per Barrage" },
                { id: 'provinceTemperature', parse: parseInt, min: -5, max: 5, prettyName: "Province Temperature" },
                { id: 'simulationRuns', parse: parseInt, min: 1, max:1000000, prettyName: "Simulation Runs" }
            ];

            document.querySelectorAll('.input-panel input[type="number"], .input-panel input[type="text"]').forEach(el => el.classList.remove('error'));

            inputConfigs.forEach(config => {
                const element = document.getElementById(config.id);
                const valueStr = element.value;
                const parsedValue = config.parse(valueStr);
                
                if (valueStr === "" || isNaN(parsedValue)) {
                    errors.push(`${config.prettyName} must be a valid number.`);
                    element.classList.add('error');
                } else {
                    if (config.min !== undefined && parsedValue < config.min) {
                        errors.push(`${config.prettyName} must be >= ${config.min}.`);
                        element.classList.add('error');
                    }
                    if (config.max !== undefined && parsedValue > config.max) {
                        errors.push(`${config.prettyName} must be <= ${config.max}.`);
                        element.classList.add('error');
                    }
                    inputs[config.id] = parsedValue;
                }
            });
            inputs.isUnitEthereal = document.getElementById('isUnitEthereal').checked;
            inputs.twistOfFateActive = document.getElementById('twistOfFateActive').checked;
            if (inputs.twistOfFateActive) {
                const tofTurnsStr = document.getElementById('twistOfFateCastTurns').value;
                inputs.parsedTwistOfFateCastTurns = parseTurnInput(tofTurnsStr);
                if (inputs.parsedTwistOfFateCastTurns === null) { 
                     errors.push(`Twist of Fate Cast Turn(s) has an invalid format. Use positive numbers, commas, and hyphens (e.g., 1, 3-5).`);
                     document.getElementById('twistOfFateCastTurns').classList.add('error');
                } else if (tofTurnsStr.trim() !== "" && inputs.parsedTwistOfFateCastTurns.length === 0 && tofTurnsStr.replace(/[0-9,\s-]/g, '').trim() !== "") { 
                     errors.push(`Twist of Fate Cast Turn(s) contains invalid characters. Only use numbers, commas, hyphens, and spaces.`);
                     document.getElementById('twistOfFateCastTurns').classList.add('error');
                } else if (tofTurnsStr.trim() === "" && inputs.twistOfFateActive){ 
                    errors.push(`Twist of Fate Cast Turn(s) must be specified if Twist of Fate is active.`);
                    document.getElementById('twistOfFateCastTurns').classList.add('error');
                }
            } else {
                inputs.parsedTwistOfFateCastTurns = [];
            }

            return errors;
        }

        function startFullSimulation() {
            const simInputs = {};
            const errors = validateInputs(simInputs);
            const errorBox = document.getElementById('errorMessages');
            const resultsDiv = document.getElementById('resultsSummary');
            const svgGraphElement = document.getElementById('deathGraphSvg');
            const runButton = document.getElementById('runSimulationButton');

            if (errors.length > 0) {
                errorBox.innerHTML = `<strong>Input errors:</strong><br>- ${errors.join('<br>- ')}`;
                errorBox.style.display = 'block';
                resultsDiv.innerHTML = "<p>Please correct input errors.</p>";
                svgGraphElement.innerHTML = '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--muted-text-color)">Graph requires valid inputs.</text>';
                return;
            }
            errorBox.style.display = 'none';
            resultsDiv.innerHTML = "<p>Running simulation, please wait...</p>";
            svgGraphElement.innerHTML = '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--muted-text-color)">Generating graph...</text>';
            runButton.disabled = true;

            setTimeout(() => {
                try {
                    let totalDeaths = 0;
                    let sumTurnOfDeath = 0; 
                    let sumOfAllInitialDamages = 0; 
                    let sumOfInitialDamage_WhenHit = 0; 
                    let countRunsWithInitialDamage = 0;
                    let sumOfAllBurnDamages = 0;
                    let sumTimesCaughtFire = 0;
                    let sumTurnsSpentBurning = 0;
                    let runsWhereCaughtFire = 0;
                    let sumCenterHits = 0;
                    let sumSplashHits = 0;
                    let sumTofNullified = 0;

                    const maxSimTurns = (simInputs.numBarrages * BARRAGE_DURATION_TURNS) + AFTERMATH_DURATION_TURNS;
                    let deathsAtTurnT = new Array(maxSimTurns + 1).fill(0); 

                    for (let i = 0; i < simInputs.simulationRuns; i++) {
                        const runResult = simulateOneFullRun(simInputs);
                        if (runResult.died) {
                            totalDeaths++;
                            sumTurnOfDeath += runResult.turnOfDeath;
                            if (runResult.turnOfDeath > 0 && runResult.turnOfDeath <= maxSimTurns) {
                                deathsAtTurnT[runResult.turnOfDeath]++;
                            }
                        }
                        
                        sumOfAllInitialDamages += runResult.totalInitialDamage;
                        if (runResult.totalInitialDamage > 0) { // Check if any initial damage was dealt in the run
                            countRunsWithInitialDamage++;
                            sumOfInitialDamage_WhenHit += runResult.totalInitialDamage; 
                        }

                        sumOfAllBurnDamages += runResult.totalBurnDamage;
                        sumTimesCaughtFire += runResult.timesCaughtFire;
                        if (runResult.timesCaughtFire > 0) {
                            runsWhereCaughtFire++;
                            sumTurnsSpentBurning += runResult.turnsSpentBurning;
                        }
                        sumCenterHits += runResult.centerHits;
                        sumSplashHits += runResult.splashHits;
                        sumTofNullified += runResult.tofNullified;
                    }

                    const deathPercentage = (totalDeaths / simInputs.simulationRuns) * 100;
                    const avgTurnOfDeathIfDied = totalDeaths > 0 ? sumTurnOfDeath / totalDeaths : 0;
                    
                    const probTakingAnyInitialDamage = (countRunsWithInitialDamage / simInputs.simulationRuns) * 100;
                    const avgInitialDamageIfHit = countRunsWithInitialDamage > 0 ? sumOfInitialDamage_WhenHit / countRunsWithInitialDamage : 0;
                    const avgCenterHitsPerRun = sumCenterHits / simInputs.simulationRuns;
                    const avgSplashHitsPerRun = sumSplashHits / simInputs.simulationRuns;
                    const avgBurnDamagePerRun = sumOfAllBurnDamages / simInputs.simulationRuns;
                    const avgTofNullifiedPerRun = sumTofNullified / simInputs.simulationRuns;

                    const percCaughtFireCurrent = (runsWhereCaughtFire / simInputs.simulationRuns) * 100; // Renamed for clarity
                    const avgTimesCaughtFireWhenCaughtCurrent = runsWhereCaughtFire > 0 ? sumTimesCaughtFire / runsWhereCaughtFire : 0; 
                    const avgTurnsBurningWhenCaughtCurrent = runsWhereCaughtFire > 0 ? sumTurnsSpentBurning / runsWhereCaughtFire : 0;

                    let outputHTML = `<div class="stat-group"><h4>Overall Statistics</h4>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Total Runs:</span><span class="stat-value">${simInputs.simulationRuns}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Unit Died:</span><span class="stat-value">${totalDeaths} (${deathPercentage.toFixed(1)}%)</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Turn of Death (if died):</span><span class="stat-value">${avgTurnOfDeathIfDied.toFixed(2)}</span></div></div>`;
                    
                    outputHTML += `<div class="stat-group"><h4>Damage Statistics</h4>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Prob. of Taking Initial Fireball Damage:</span><span class="stat-value">${probTakingAnyInitialDamage.toFixed(1)}%</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Initial Fireball Damage (if hit):</span><span class="stat-value">${avgInitialDamageIfHit.toFixed(2)}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Center Hits / Run:</span><span class="stat-value">${avgCenterHitsPerRun.toFixed(2)}</span></div>`; 
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Splash Hits / Run:</span><span class="stat-value">${avgSplashHitsPerRun.toFixed(2)}</span></div>`; 
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Burn Damage / Run:</span><span class="stat-value">${avgBurnDamagePerRun.toFixed(2)}</span></div>`;
                    if (simInputs.twistOfFateActive) {
                         outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Dmg Instances Nullified by ToF / Run:</span><span class="stat-value">${avgTofNullifiedPerRun.toFixed(2)}</span></div>`;
                    }
                    outputHTML += `</div>`;

                    outputHTML += `<div class="stat-group"><h4>Fire Status Statistics</h4>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Runs Unit Caught Fire:</span><span class="stat-value">${runsWhereCaughtFire} (${percCaughtFireCurrent.toFixed(1)}%)</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Times Caught Fire (if caught):</span><span class="stat-value">${avgTimesCaughtFireWhenCaughtCurrent.toFixed(2)}</span></div>`;
                    outputHTML += `<div class="stat-item"><span class="stat-label">Avg. Turns Spent Burning (if caught):</span><span class="stat-value">${avgTurnsBurningWhenCaughtCurrent.toFixed(2)}</span></div></div>`;
                    
                    resultsDiv.innerHTML = outputHTML;

                    let probDyingInTurnT_data = deathsAtTurnT.slice(1).map(d => (d / simInputs.simulationRuns) * 100); 
                    let cumulativeProbDeadByTurnT_data = [];
                    let cumulativeDeaths = 0;
                    for (let i = 1; i <= maxSimTurns; i++) {
                        cumulativeDeaths += deathsAtTurnT[i];
                        cumulativeProbDeadByTurnT_data.push((cumulativeDeaths / simInputs.simulationRuns) * 100);
                    }
                    drawDeathGraph(svgGraphElement, maxSimTurns, probDyingInTurnT_data, cumulativeProbDeadByTurnT_data);

                } catch (error) {
                    resultsDiv.innerHTML = `<p style="color:red;">Simulation Error: ${error.message}</p><pre>${error.stack}</pre>`;
                    svgGraphElement.innerHTML = '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--muted-text-color)">Error generating graph.</text>';
                    console.error("Simulation error:", error);
                } finally {
                    runButton.disabled = false;
                }
            }, 10); 
        }

        function drawDeathGraph(svgElement, maxTurnsToGraph, probDyingInTurnT_data, cumulativeProbDeadByTurnT_data) {
            svgElement.innerHTML = ''; 
            const svgNS = "http://www.w3.org/2000/svg";
            const actualWidth = svgElement.parentElement.clientWidth; 
            svgElement.setAttribute('width', actualWidth);
            const height = parseInt(svgElement.getAttribute('height'));
            const margin = { top: 20, right: 30, bottom: 50, left: 60 }; 
            const graphWidth = actualWidth - margin.left - margin.right;
            const graphHeight = height - margin.top - margin.bottom;

            if (graphWidth <=0 || graphHeight <=0) { 
                svgElement.innerHTML = '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--muted-text-color)">Not enough space for graph.</text>'; 
                return; 
            }
            const numDataPoints = maxTurnsToGraph;
            if (numDataPoints === 0 || probDyingInTurnT_data.length === 0) { 
                svgElement.innerHTML = '<text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="var(--muted-text-color)">No data for graph.</text>'; 
                return;
            }

            const xScale = (turnIndex) => margin.left + (turnIndex / (numDataPoints > 1 ? numDataPoints -1 : 1)) * graphWidth; 
            const yScale = (percentage) => margin.top + graphHeight - (Math.max(0, Math.min(100, percentage)) / 100) * graphHeight; 
            
            const gridGroup = document.createElementNS(svgNS, 'g'); 
            gridGroup.setAttribute('class', 'graph-grid'); 
            svgElement.appendChild(gridGroup);
            
            const xAxisLine = document.createElementNS(svgNS, 'line'); 
            xAxisLine.setAttributes({ x1: margin.left, y1: margin.top + graphHeight, x2: margin.left + graphWidth, y2: margin.top + graphHeight, class: 'graph-axis boundary-line' }); 
            svgElement.appendChild(xAxisLine);
            const yAxisLine = document.createElementNS(svgNS, 'line'); 
            yAxisLine.setAttributes({ x1: margin.left, y1: margin.top, x2: margin.left, y2: margin.top + graphHeight, class: 'graph-axis boundary-line' }); 
            svgElement.appendChild(yAxisLine);

            const numXTicks = Math.min(10, numDataPoints > 0 ? numDataPoints : 1);
            const xTickValues = new Set(); 

            for (let i = 0; i <= numXTicks; i++) {
                const turnValRaw = numDataPoints > 1 ? (i * (numDataPoints) / numXTicks) : (numDataPoints === 1 ? 1 : i) ;
                let turnValDisplay = Math.max(1, Math.round(turnValRaw)); 
                if (i === 0 && numDataPoints > 0) turnValDisplay = 1; 
                if (i === numXTicks && numDataPoints > 0) turnValDisplay = numDataPoints; 

                if (xTickValues.has(turnValDisplay) && i !== 0 && i !== numXTicks) continue; 
                xTickValues.add(turnValDisplay);

                const turnValForScale = turnValDisplay -1; 
                
                const x = xScale(turnValForScale);
                if (x < margin.left -1 || x > margin.left + graphWidth +1 ) continue; 

                const tick = document.createElementNS(svgNS, 'line'); 
                tick.setAttributes({ x1: x, y1: margin.top + graphHeight, x2: x, y2: margin.top + graphHeight + 6, class: 'graph-axis tick-line' }); 
                svgElement.appendChild(tick);
                const label = document.createElementNS(svgNS, 'text'); 
                label.setAttributes({ x: x, y: margin.top + graphHeight + 20, 'text-anchor': 'middle', class: 'graph-axis' }); 
                label.textContent = turnValDisplay; 
                svgElement.appendChild(label);

                if (turnValDisplay !== 1 && turnValDisplay !== numDataPoints && numDataPoints > 1 ) { 
                    const gridLine = document.createElementNS(svgNS, 'line'); 
                    gridLine.setAttributes({ x1: x, y1: margin.top, x2: x, y2: margin.top + graphHeight, class: 'graph-grid-line' }); 
                    gridGroup.appendChild(gridLine);
                }
            }
            
            const xAxisLabel = document.createElementNS(svgNS, 'text'); 
            xAxisLabel.setAttributes({x: margin.left + graphWidth/2, y: height - 10, 'text-anchor':'middle', class:'graph-axis', 'font-weight':'500'}); 
            xAxisLabel.textContent = "Game Turn"; 
            svgElement.appendChild(xAxisLabel);

            for (let i = 0; i <= 10; i++) { 
                const perc = i * 10; 
                const y = yScale(perc);
                const tick = document.createElementNS(svgNS, 'line'); 
                tick.setAttributes({ x1: margin.left - 6, y1: y, x2: margin.left, y2: y, class: 'graph-axis tick-line' }); 
                svgElement.appendChild(tick);
                const label = document.createElementNS(svgNS, 'text'); 
                label.setAttributes({ x: margin.left - 10, y: y, 'text-anchor': 'end', 'dominant-baseline': 'middle', class: 'graph-axis' }); 
                label.textContent = perc + '%'; 
                svgElement.appendChild(label);
                if (i > 0 && i < 10) { 
                    const gridLine = document.createElementNS(svgNS, 'line'); 
                    gridLine.setAttributes({ x1: margin.left, y1: y, x2: margin.left + graphWidth, y2: y, class: 'graph-grid-line' }); 
                    gridGroup.appendChild(gridLine);
                }
            }
            // Y-axis title text element (e.g., "Percentage (%)") is intentionally omitted here as per request.
            
            const createPointsString = (data, xMap, yMap) => data.map((d, i) => `${xMap(i).toFixed(2)},${yMap(d).toFixed(2)}`).join(' ');
            
            if (probDyingInTurnT_data.length > 0) { 
                const polyline1 = document.createElementNS(svgNS, 'polyline'); 
                polyline1.setAttribute('points', createPointsString(probDyingInTurnT_data, xScale, yScale)); 
                polyline1.setAttribute('class', 'graph-line line1'); 
                svgElement.appendChild(polyline1); 
            }
            if (cumulativeProbDeadByTurnT_data.length > 0) { 
                const polyline2 = document.createElementNS(svgNS, 'polyline'); 
                polyline2.setAttribute('points', createPointsString(cumulativeProbDeadByTurnT_data, xScale, yScale)); 
                polyline2.setAttribute('class', 'graph-line line2'); 
                svgElement.appendChild(polyline2); 
            }
        }
    </script>
</body>
</html>
