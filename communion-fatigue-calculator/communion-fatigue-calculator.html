<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dominions 6 – Communion Simulator (with Rigor)</title>
    <script src='https://cdn.plot.ly/plotly-latest.min.js'></script>
    <style>
        :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --background-color: #f8f9fa;
            --card-background: #ffffff;
            --text-color: #333333;
            --input-border: #ced4da;
            --error-color: #dc3545;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --spacing-unit: 1rem;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        body {
            font-family: var(--font-family);
            line-height: 1.6;
            margin: 0;
            background-color: var(--background-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            padding: var(--spacing-unit);
            min-height: 100vh;
            box-sizing: border-box;
        }

        .container {
            display: grid;
            grid-template-columns: minmax(300px, 1fr) 2fr;
            grid-template-rows: auto auto;
            gap: calc(var(--spacing-unit) * 1.5);
            max-width: 1200px;
            width: 100%;
            background-color: var(--card-background);
            padding: calc(var(--spacing-unit) * 1.5);
            border-radius: 0.5rem;
            box-shadow: var(--shadow);
        }

        .input-column, .output-column {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-unit);
        }

        .docs-container {
            grid-column: 1 / -1;
            margin-top: var(--spacing-unit);
        }

        fieldset {
            border: 1px solid var(--input-border);
            padding: var(--spacing-unit);
            border-radius: 0.375rem;
            background-color: var(--card-background);
            margin: 0;
        }

        legend {
            padding: 0 0.5rem;
            font-size: 1.1em;
            font-weight: 600;
            color: var(--secondary-color);
        }

        .input-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 0.5rem 1rem;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .input-grid label {
            font-size: 0.95em;
            color: var(--text-color);
            white-space: nowrap;
        }

        .input-grid input[type="number"],
        .input-grid input[type="checkbox"] {
            padding: 0.375rem 0.75rem;
            border: 1px solid var(--input-border);
            border-radius: 0.25rem;
            font-size: 0.95em;
            background-color: var(--card-background);
            transition: border-color 0.2s;
        }

        .input-grid input[type="number"] {
            width: 100px;
        }

        .input-grid input[type="checkbox"] {
            width: auto;
            margin-right: 0.5rem;
        }

        .input-grid input:focus {
            border-color: var(--primary-color);
            outline: none;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
        }

        .sim-controls {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .sim-controls div {
            display: flex;
            align-items: center;
        }

        .sim-controls .button-group {
            margin-top: 0.75rem;
            display: flex;
            gap: 0.5rem;
        }

        .sim-controls button {
            padding: 0.5rem 1rem;
            cursor: pointer;
            border: none;
            border-radius: 0.25rem;
            background-color: var(--primary-color);
            color: white;
            font-size: 0.95em;
            transition: background-color 0.2s, transform 0.1s;
        }

        .sim-controls button:hover {
            background-color: #0056b3;
            transform: translateY(-1px);
        }

        .sim-controls button:active {
            transform: translateY(0);
        }

        #output-text {
            font-family: "Courier New", Courier, monospace;
            font-size: 0.9em;
            white-space: pre;
            background-color: #f1f3f5;
            padding: 1rem;
            border: 1px solid var(--input-border);
            border-radius: 0.375rem;
            min-height: 150px;
            overflow-x: auto;
        }

        .charts-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            width: 100%;
        }

        .chart {
            border: 1px solid var(--input-border);
            border-radius: 0.375rem;
            min-height: 400px;
            background-color: var(--card-background);
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .error-input {
            background-color: #fff5f5;
            border-color: var(--error-color) !important;
        }

        .one-off-spell-input-row {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem 1rem;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .one-off-spell-input-row > div {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .one-off-spell-input-row label {
            font-size: 0.9em;
            white-space: nowrap;
        }

        .one-off-spell-input-row input[type="number"] {
            width: 70px;
            padding: 0.375rem;
            font-size: 0.9em;
        }

        .one-off-spell-input-row input[type="checkbox"] {
            margin-left: 0;
            padding: 0.375rem;
        }

        #add_one_off_spell_button {
            margin-bottom: 0.75rem;
            padding: 0.5rem 1rem;
            cursor: pointer;
            border: none;
            border-radius: 0.25rem;
            background-color: var(--primary-color);
            color: white;
            font-size: 0.95em;
            transition: background-color 0.2s, transform 0.1s;
        }

        #add_one_off_spell_button:hover {
            background-color: #0056b3;
            transform: translateY(-1px);
        }

        #one_off_spells_list_container {
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid var(--input-border);
            padding: 0.5rem;
            background-color: var(--card-background);
            border-radius: 0.25rem;
        }

        .listed-one-off-spell {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.375rem 0.5rem;
            border-bottom: 1px solid #e9ecef;
            font-size: 0.85em;
        }

        .listed-one-off-spell:last-child {
            border-bottom: none;
        }

        .listed-one-off-spell span {
            flex-grow: 1;
            margin-right: 0.5rem;
            color: var(--text-color);
        }

        .remove-listed-spell {
            padding: 0.25rem 0.75rem;
            font-size: 0.8em;
            background-color: #dc3545;
            border: none;
            border-radius: 0.25rem;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .remove-listed-spell:hover {
            background-color: #c82333;
        }

        .no-one-off-spells-message {
            color: var(--secondary-color);
            font-style: italic;
            text-align: center;
            font-size: 0.9em;
            padding: 0.75rem 0;
        }

        .rigor-details {
            padding-left: 1.5rem;
            margin-top: 0.5rem;
            border-left: 2px solid #dee2e6;
        }

        details {
            border: 1px solid var(--input-border);
            border-radius: 0.375rem;
            padding: 1rem;
            background-color: #f8f9fa;
        }

        summary {
            cursor: pointer;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--secondary-color);
        }

        .docs-content {
            font-size: 0.95em;
            line-height: 1.6;
            color: var(--text-color);
        }

        .docs-content h4 {
            margin-top: 1rem;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 0.25rem;
            font-size: 1.1em;
            color: var(--secondary-color);
        }

        .docs-content h4:first-of-type {
            margin-top: 0;
        }

        .docs-content p, .docs-content ul {
            margin-top: 0;
            margin-bottom: 0.75rem;
        }

        .docs-content ul {
            padding-left: 1.5rem;
        }

        .docs-content ol {
            padding-left: 1.5rem;
        }

        .docs-content li {
            margin-bottom: 0.25rem;
        }

        .docs-content code {
            background-color: #e9ecef;
            padding: 0.2rem 0.4rem;
            border-radius: 0.25rem;
            font-family: Consolas, "Courier New", monospace;
            font-size: 0.9em;
            color: #d63384;
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto;
            }

            .input-column {
                grid-column: 1 / -1;
                grid-row: 1 / 2;
            }

            .output-column {
                grid-column: 1 / -1;
                grid-row: 2 / 3;
            }

            .docs-container {
                grid-column: 1 / -1;
                grid-row: 3 / 4;
            }

            .one-off-spell-input-row {
                gap: 0.5rem 0.75rem;
            }

            .one-off-spell-input-row input[type="number"] {
                width: 60px;
            }

            .rigor-details {
                padding-left: 0.5rem;
                border-left: none;
            }

            .chart {
                min-height: 300px;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <div class="input-column">
        <fieldset>
            <legend>Spell Settings (Main Communion Spell)</legend>
            <div class="input-grid">
                <label for="base_fatigue">Base Fatigue:</label><input type="number" id="base_fatigue" value="40">
                <label for="path_req">Path Req:</label><input type="number" id="path_req" value="2" step="1">
                <label for="enc">Encumbrance (Master):</label><input type="number" id="enc" value="3">
                <label for="mag_scale">Magic Scale:</label><input type="number" id="mag_scale" value="0" min="-3" max="3" step="1">
            </div>
        </fieldset>

        <fieldset>
            <legend>Caster/Slave Settings (Main Communion Path)</legend>
            <div class="input-grid">
                <label for="caster_lvl">Caster Level:</label><input type="number" id="caster_lvl" value="1" step="1" min="0">
                <label for="slave_lvl">Slave Level:</label><input type="number" id="slave_lvl" value="1" step="1" min="0">
                <label for="n_slaves">Number of Slaves:</label><input type="number" id="n_slaves" value="8" step="1" min="0">
                <label for="n_masters">Number of Masters:</label><input type="number" id="n_masters" value="4" step="1" min="1">
                <label for="communion_mr">Communion MR:</label><input type="number" id="communion_mr" value="12" min="0"> 
            </div>
        </fieldset>

        <fieldset>
            <legend>Fatigue/HP Settings</legend>
            <div class="input-grid">
                <label for="initial_slave_fatigue">Initial Slave Fat:</label><input type="number" id="initial_slave_fatigue" value="23">
                <label for="initial_master_fatigue">Initial Master Fat:</label><input type="number" id="initial_master_fatigue" value="23">
                <label for="slave_hp">Slave HP:</label><input type="number" id="slave_hp" value="10" step="1" min="1">
                <label for="extra_slave_reinvig">Extra Slave Reinvig/Turn:</label><input type="number" id="extra_slave_reinvig" value="0">
                <label for="extra_master_reinvig">Extra Master Reinvig/Turn:</label><input type="number" id="extra_master_reinvig" value="0">
                <label for="regen">Healing (HP)/Turn:</label><input type="number" id="regen" value="0">
            </div>
        </fieldset>
        
        <fieldset>
            <legend>Simulation & Battlefield Settings</legend>
            <div class="input-grid">
                <label for="n_turns">Turns:</label><input type="number" id="n_turns" value="100" step="1" min="1" max="10000">
            </div>
            <div class="sim-controls">
                 <div>
                     <input type="checkbox" id="relief_spell_effect">
                     <label for="relief_spell_effect">Relief spell active</label>
                 </div>
                 <div>
                    <input type="checkbox" id="applyBattlefieldRigor">
                    <label for="applyBattlefieldRigor">Enable Battlefield Rigor Mortis?</label>
                </div>
                <div id="rigorMortisDetails" class="input-grid rigor-details" style="display:none;">
                    <label for="rigorPenBonus">Rigor Extra Pen:</label><input type="number" id="rigorPenBonus" value="0" min="0">
                </div>
                 <div class="button-group">
                     <button id="simulate_button">Simulate</button>
                     <button id="reset_button">Reset</button>
                 </div>
            </div>
        </fieldset>

        <fieldset>
            <legend>One-Off Spells (Slave Fatigue Only)</legend>
            <div class="one-off-spell-input-row">
                <div><label for="one_off_turn_input">Turn:</label><input type="number" id="one_off_turn_input" min="1" step="1" value="1"></div>
                <div><label for="one_off_base_fatigue_input">Base Fat:</label><input type="number" id="one_off_base_fatigue_input" min="0" value="50"></div>
                <div><label for="one_off_path_req_input">Path Req:</label><input type="number" id="one_off_path_req_input" min="0" step="1" value="1"></div>
                <div><label for="one_off_caster_lvl_input">Caster Lvl:</label><input type="number" id="one_off_caster_lvl_input" min="0" step="1" value="1"></div>
                <div><label for="one_off_is_off_path_input">Off-Path:</label><input type="checkbox" id="one_off_is_off_path_input"></div>
            </div>
            <button type="button" id="add_one_off_spell_button">Add Spell to List</button>
            <div id="one_off_spells_list_container">
                <p class="no-one-off-spells-message">No one-off spells added yet.</p>
            </div>
            <p style="font-size:0.8em; margin-top:8px; color:#555;">
                These spells add fatigue directly to the slave pool. Uses global Magic Scale & Num Slaves. Master Encumbrance is not applied.
                The "Off-Path" checkbox for one-off spells means slaves are considered path 0 for calculating their fatigue multiplier for that specific spell.
            </p>
        </fieldset>
    </div> 

    <div class="output-column">
        <pre id="output-text">Run simulation to see results.</pre>
        <div class="charts-container">
            <div class="chart" id="hp-chart"></div>
            <div class="chart" id="fatigue-chart"></div>
            <div class="chart" id="master-fatigue-chart"></div>
        </div>
    </div> 

    <div class="docs-container">
        <details> <summary>Documentation & How It Works</summary> <div class="docs-content">
            <h4>Purpose:</h4>
            <p>This tool simulates fatigue and HP loss for a communion over time, considering main spellcasting, one-off spells, and an optional recurring Battlefield Rigor Mortis effect.</p>
            <h4>How to Use (Inputs):</h4>
            <p><strong>Spell Settings (Main Communion Spell):</strong></p>
            <ul>
                <li>Base Fatigue: Fatigue cost of the spell before modifications.</li>
                <li>Path Req: Required magic path level to cast the spell.</li>
                <li>Encumbrance (Master): Master's encumbrance, adding to fatigue.</li>
                <li>Magic Scale: Province magic scale (-3 to +3), affects fatigue costs.</li>
            </ul>
            <p><strong>Caster/Slave Settings (Main Communion Path):</strong></p>
            <ul>
                <li>Caster Level: Master's magic level in the spell's path (for main communion spell).</li>
                <li>Slave Level: Slave's magic level in the path (for main communion spell, and for one-off spells if "Off-Path" is not checked for them).</li>
                <li>Number of Slaves: Total communion slaves.</li>
                <li>Number of Masters: Total communion masters casting the main spell.</li>
                <li>Communion MR: Magic Resistance for masters and slaves against Rigor Mortis.</li>
            </ul>
            <p><strong>Fatigue/HP Settings:</strong></p>
            <ul>
                <li>Initial Slave Fat: Starting fatigue of the slave pool.</li>
                <li>Initial Master Fat: Starting fatigue of each master.</li>
                <li>Slave HP: Starting HP of the slave pool.</li>
                <li>Extra Slave Reinvig/Turn: Additional fatigue recovery per turn for slaves.</li>
                <li>Extra Master Reinvig/Turn: Additional fatigue recovery per turn for masters.</li>
                <li>Healing (HP)/Turn: HP regeneration per turn for slaves.</li>
            </ul>
            <p><strong>Simulation & Battlefield Settings:</strong></p>
            <ul>
                <li>Turns: Number of turns to simulate (1–10000).</li>
                <li>Relief spell active: If checked, applies fatigue recovery each turn.</li>
                <li>Enable Battlefield Rigor Mortis?: Check to activate the Rigor Mortis effect.
                    <ul>
                        <li>Rigor Extra Pen: Additional penetration bonus for Rigor Mortis.</li>
                    </ul>
                </li>
            </ul>
            <p><strong>One-Off Spells:</strong></p>
            <ul>
                <li>Turn: Turn the spell is cast.</li>
                <li>Base Fat: Base fatigue cost of the spell.</li>
                <li>Path Req: Required path level for this specific spell.</li>
                <li>Caster Lvl: Caster’s level in the path for this specific spell.</li>
                <li>Off-Path: If checked, slaves are considered path level 0 for calculating their fatigue multiplier for this specific spell. If unchecked, the global "Slave Level" is used.</li>
            </ul>
            <h4>Mechanics Modeled (Attempting to match spreadsheet and game definitions):</h4>
            <p><strong>Single Exploding Die (<code>openD6_dom</code>):</strong> A d6 roll. If '6', counts as 5 and re-rolls, adding new result. Repeats for more '6's.</p>
            <p><strong>Dominions Random Number (DRN):</strong> As per game definition: <code>openD6_dom() + openD6_dom()</code>. Calculated by <code>calculate_game_DRN()</code>.</p>
            <p><strong>Communion Master Level (CM Level):</strong> <code>FLOOR(LOG2(Number_of_Slaves)) + Caster_Level</code>.</p>
            <p><strong>Master Fatigue Component (<code>MFC_base</code>):</strong> <code>(Base_Spell_Fatigue / (1 + MAX(0, CM_Level - Spell_Path_Req))) * (1 - 0.1 * Magic_Scale)</code>.</p>
            <p><strong>Master Fatigue Cost (per main spell):</strong> <code>Master_Final_Cost = (MFC_base + Master_Encumbrance) / (1 + Number_of_Slaves)</code>.</p>
            <p><strong>Slave Fatigue Multiplier:</strong> Based on Caster Level (<code>CL</code>) vs Slave Level (<code>SL</code>):
                <ul>
                    <li>If <code>SL == 0</code>: If <code>CL == 1</code>, then <code>2x</code>; Else, <code>4x</code>.</li>
                    <li>Else (<code>SL > 0</code>): If <code>FLOOR(CL / 2) > SL</code>, then <code>4x</code>; Else if <code>CL > SL</code>, then <code>2x</code>; Else if <code>CL == SL</code>, then <code>1x</code>; Else (<code>CL < SL</code>), then <code>0.5x</code>.</li>
                </ul>
            </p>
            <p><strong>Slave Fatigue Cost (per main spell):</strong> <code>Master_Final_Cost * Slave_Fatigue_Multiplier</code>.</p>
            <p><strong>One-Off Spell Slave Fatigue:</strong> <code>(MFC_base_one_off / (1 + Number_of_Slaves)) * Slave_Fatigue_Multiplier_one_off</code>. (No master encumbrance).</p>
            <p><strong>Fatigue Damage (when fatigue reaches or exceeds 200):</strong>
                For main/one-off spells: <code>1 + FLOOR(Fatigue_Cost_that_Pushed_to_200 / 50)</code>. Applied for each event causing fatigue >= 200.
                For Rigor Mortis: 1 HP damage if its fatigue addition causes slave fatigue >= 200.
            </p>
            <p>The simulation proceeds turn by turn (order of operations):</p>
            <ol>
               <li><strong>Battlefield Rigor Mortis (if enabled):</strong> Pulses occur. For each hit on slaves, fatigue applied. If slave fatigue reaches/exceeds 200 due to this pulse, 1 HP damage taken. Masters also take fatigue if hit.</li>
               <li><strong>One-Off Spells:</strong> For each, fatigue applied to slaves. If slave fatigue reaches/exceeds 200 due to this spell, calculated HP damage taken.</li>
               <li><strong>Main Communion Spell Casting:</strong> Each active master casts. Master takes fatigue. For each master's cast, slave fatigue is added. If slave fatigue reaches/exceeds 200 due to *this specific master's contribution*, calculated HP damage taken.</li>
               <li><strong>Relief Spell (if active):</strong> Recovers <code>max(0, 1 + calculate_game_DRN() - calculate_game_DRN())</code> fatigue.</li>
               <li><strong>Natural Fatigue Recovery:</strong> Standard recovery + Extra Reinvig.</li>
               <li><strong>HP Regeneration:</strong> Slaves heal HP.</li>
            </ol>
        </div> </details>
    </div>
</div>

<script>
    const defaultValues = {
        base_fatigue: 40, path_req: 2, enc: 3, mag_scale: 0,
        caster_lvl: 1, slave_lvl: 1, n_slaves: 8, n_masters: 4, communion_mr: 12,
        initial_slave_fatigue: 23, initial_master_fatigue: 23, slave_hp: 10,
        extra_slave_reinvig: 0, extra_master_reinvig: 0, regen: 0, 
        n_turns: 100, relief_spell_effect: false, applyBattlefieldRigor: false, rigorPenBonus: 0
    };

    // --- Dominions Dice Mechanics ---
    // Simulates one open-ended d6 (if roll is 6, count as 5 and add reroll)
    function openD6_dom() {
        let total = 0; let roll;
        do {
            roll = Math.floor(Math.random() * 6) + 1;
            total += (roll === 6 ? 5 : roll); 
        } while (roll === 6);
        return total;
    }

    // Calculates one game-defined Dominions Random Number (DRN) = open-ended 2d6
    function calculate_game_DRN() { 
        return openD6_dom() + openD6_dom();
    }

    const outputTextElement = document.getElementById('output-text');
    const inputIds = Object.keys(defaultValues); 
    const oneOffTurnInput = document.getElementById('one_off_turn_input');
    const oneOffBaseFatigueInput = document.getElementById('one_off_base_fatigue_input');
    const oneOffPathReqInput = document.getElementById('one_off_path_req_input');
    const oneOffCasterLvlInput = document.getElementById('one_off_caster_lvl_input');
    const oneOffIsOffPathInput = document.getElementById('one_off_is_off_path_input');
    const addOneOffSpellButton = document.getElementById('add_one_off_spell_button');
    const oneOffSpellsListContainer = document.getElementById('one_off_spells_list_container');
    const noOneOffSpellsMessage = oneOffSpellsListContainer.querySelector('.no-one-off-spells-message');
    const applyBattlefieldRigorCheckbox = document.getElementById('applyBattlefieldRigor');
    const rigorMortisDetailsDiv = document.getElementById('rigorMortisDetails');

	function comm_master_level(slaves, caster_lvl_for_spell) {
		slaves = Math.floor(slaves); caster_lvl_for_spell = Math.floor(caster_lvl_for_spell);
		if (slaves <= 0) return caster_lvl_for_spell; 
		const bonus = Math.floor(Math.log2(slaves));
		return caster_lvl_for_spell + Math.max(0, bonus); 
	}

    function slave_fatigue_multiplier(caster_lvl_for_spell, slave_lvl_for_spell) {
        caster_lvl_for_spell = Math.floor(caster_lvl_for_spell); slave_lvl_for_spell = Math.floor(slave_lvl_for_spell);
        if (slave_lvl_for_spell === 0) return caster_lvl_for_spell === 1 ? 2.0 : 4.0;
        else {
            if (Math.floor(caster_lvl_for_spell / 2) > slave_lvl_for_spell) return 4.0;
            else if (caster_lvl_for_spell > slave_lvl_for_spell) return 2.0;
            else if (caster_lvl_for_spell === slave_lvl_for_spell) return 1.0;
            else return 0.5;
        }
    }

    function calculate_one_off_spell_slave_effects(spell_details, global_p) {
        const { base_fatigue, path_req, caster_lvl, is_off_path } = spell_details;
        const cm_lvl_one_off = comm_master_level(global_p.n_slaves, caster_lvl);
        const path_diff_one_off = cm_lvl_one_off - path_req;
        let fatigue_reduction_divisor_one_off = 1 + Math.max(0, path_diff_one_off);
        if (fatigue_reduction_divisor_one_off <= 0) fatigue_reduction_divisor_one_off = 1; 
        let mfc_base_one_off = base_fatigue / fatigue_reduction_divisor_one_off;
        mfc_base_one_off *= (1 - 0.1 * global_p.mag_scale);
        mfc_base_one_off = Math.max(0, mfc_base_one_off); 
        const slave_lvl_for_this_spell = is_off_path ? 0 : global_p.slave_lvl;
        const s_mult_one_off = slave_fatigue_multiplier(caster_lvl, slave_lvl_for_this_spell);
        const communion_divisor = 1 + Math.max(0, global_p.n_slaves); 
        const s_cost_one_off = (mfc_base_one_off / communion_divisor) * s_mult_one_off;
        const fatigue_to_add = Math.max(0, s_cost_one_off); 
        const damage_if_overflow = (fatigue_to_add > 0) ? (1 + Math.floor(fatigue_to_add / 50)) : 0;
        return { fatigue: fatigue_to_add, damage: damage_if_overflow };
    }

    function simulate(p) {
        let rigorTotalEffectPenetration = 0;
        if (p.applyBattlefieldRigor) {
            rigorTotalEffectPenetration = 15 + Math.floor(p.mag_scale / 2) + p.rigorPenBonus;
        }
        let rigorPulseRemainder = 0; 

        const cm_lvl_main_spell = comm_master_level(p.n_slaves, p.caster_lvl);
        const path_diff_main = cm_lvl_main_spell - p.path_req;
        let fatigue_reduction_divisor_main = 1 + Math.max(0, path_diff_main);
        if (fatigue_reduction_divisor_main <= 0) fatigue_reduction_divisor_main = 1; 
        let mfc_base_main_spell = p.base_fatigue / fatigue_reduction_divisor_main;
        mfc_base_main_spell *= (1 - 0.1 * p.mag_scale);
        mfc_base_main_spell = Math.max(0, mfc_base_main_spell);
        const communion_divisor_val = 1 + Math.max(0, p.n_slaves);
        const m_cost_master_share = (mfc_base_main_spell + p.enc) / communion_divisor_val;
        const s_mult_main_spell = p.n_slaves > 0 ? slave_fatigue_multiplier(p.caster_lvl, p.slave_lvl) : 0;
        const s_cost_main_spell = p.n_slaves > 0 ? (m_cost_master_share * s_mult_main_spell) : 0; 
        const dmg_cast_main_spell = (p.n_slaves > 0 && s_cost_main_spell > 0) ? (1 + Math.floor(s_cost_main_spell / 50)) : 0;

        const initial_mf_val = Math.max(0, Math.min(p.initial_master_fatigue, 200));
        let mf = Array(p.n_masters).fill(initial_mf_val);
        let resting = Array(p.n_masters).fill(false);
        let mf_hist = Array(p.n_masters).fill(null).map(() => [initial_mf_val]);
        let cast_count = Array(p.n_masters).fill(0);
        let fatigue = p.n_slaves > 0 ? Math.max(0, Math.min(p.initial_slave_fatigue, 200)) : 0;
        let hp = p.n_slaves > 0 ? Math.max(1, p.slave_hp) : 1;
        const initial_hp = p.n_slaves > 0 ? hp : 1;
        let fat_hist = [fatigue]; let hp_hist = [hp];
        let slaves_active = (p.n_slaves > 0 && hp > 0);

        const oneOffSpellsByTurn = {};
        if (p.one_off_spells && p.n_slaves > 0) {
            p.one_off_spells.forEach(spell => {
                if (!oneOffSpellsByTurn[spell.turn]) oneOffSpellsByTurn[spell.turn] = [];
                oneOffSpellsByTurn[spell.turn].push(spell);
            });
        }
        
        for (let turn = 1; turn <= p.n_turns; turn++) {
            // 1. Battlefield Rigor Mortis
            if (p.applyBattlefieldRigor && slaves_active) {
                rigorPulseRemainder += 0.4375;
                const actualPulsesThisTurn = 23 + Math.floor(rigorPulseRemainder);
                rigorPulseRemainder -= Math.floor(rigorPulseRemainder);
                for (let pulse = 0; pulse < actualPulsesThisTurn; pulse++) {
                    if (!slaves_active) break;
                    for (let i = 0; i < p.n_masters; i++) { // Rigor for Masters
                        if (mf[i] < 200 && Math.random() < 0.03) { 
                            if (rigorTotalEffectPenetration > (p.communion_mr + calculate_game_DRN())) { // CORRECTED DRN USAGE
                                const rigorFatigueApplied = Math.max(0, 10 + calculate_game_DRN() - calculate_game_DRN()); // CORRECTED DRN USAGE
                                mf[i] = Math.min(200, mf[i] + rigorFatigueApplied);
                            }
                        }
                    }
                    if (slaves_active && Math.random() < 0.03) { // Rigor for Slaves
                        if (rigorTotalEffectPenetration > (p.communion_mr + calculate_game_DRN())) { // CORRECTED DRN USAGE
                            const rigorFatigueAppliedToSlaves = Math.max(0, 10 + calculate_game_DRN() - calculate_game_DRN()); // CORRECTED DRN USAGE
                            if (rigorFatigueAppliedToSlaves > 0) { // Only process if fatigue is actually added
                                if (fatigue === 200 || (fatigue < 200 && fatigue + rigorFatigueAppliedToSlaves >= 200)) {
                                    hp = Math.max(0, hp - 1); // Rigor damage is 1 HP
                                    if (hp === 0) slaves_active = false;
                                }
                                fatigue = Math.min(200, fatigue + rigorFatigueAppliedToSlaves);
                                if (!slaves_active) break; 
                            }
                        }
                    }
                }
            }
            
            // 2. One-Off Spells
            if (slaves_active && oneOffSpellsByTurn[turn]) {
                for (const spell_data of oneOffSpellsByTurn[turn]) {
                    if (!slaves_active) break;
                    const { fatigue: one_off_fatigue_to_add, damage: one_off_damage } = calculate_one_off_spell_slave_effects(spell_data, p);
                    if (one_off_fatigue_to_add > 0) {
                        if (fatigue === 200 || (fatigue < 200 && fatigue + one_off_fatigue_to_add >= 200)) {
                            hp = Math.max(0, hp - one_off_damage);
                            if (hp === 0) slaves_active = false;
                        }
                        fatigue = Math.min(200, fatigue + one_off_fatigue_to_add);
                        if (!slaves_active) break; 
                    }
                }
            }
            
            // 3. Main Communion Spell Casting
            let active_masters_this_turn_indices = [];
            for (let i = 0; i < p.n_masters; i++) {
                if (mf[i] < 100 && !resting[i]) active_masters_this_turn_indices.push(i);
            }
            active_masters_this_turn_indices.sort((a, b) => cast_count[a] - cast_count[b] || mf[a] - mf[b]);
            const masters_who_will_cast_count = active_masters_this_turn_indices.length; 

            if (slaves_active && masters_who_will_cast_count > 0) {
                for (let i = 0; i < masters_who_will_cast_count; i++) {
                    if (!slaves_active) break; 
                    const master_idx = active_masters_this_turn_indices[i];
                    mf[master_idx] = Math.min(200, mf[master_idx] + m_cost_master_share);
                    cast_count[master_idx]++;
                    if (mf[master_idx] >= 100) resting[master_idx] = true; 
                    
                    if (s_cost_main_spell > 0) {
                        if (fatigue === 200 || (fatigue < 200 && fatigue + s_cost_main_spell >= 200)) { // CORRECTED DAMAGE LOGIC
                            hp = Math.max(0, hp - dmg_cast_main_spell);
                            if (hp === 0) slaves_active = false;
                        }
                        fatigue = Math.min(200, fatigue + s_cost_main_spell);
                        if (!slaves_active) break; 
                    }
                }
            }
            
            // 4. Relief Spell
            if (p.relief_spell_effect) {
                const fatigueRecoveredByRelief = Math.max(0, 1 + calculate_game_DRN() - calculate_game_DRN()); // CORRECTED DRN USAGE
                if (slaves_active) fatigue = Math.max(fatigue - fatigueRecoveredByRelief, 0);
                for (let i = 0; i < p.n_masters; i++) mf[i] = Math.max(mf[i] - fatigueRecoveredByRelief, 0);
            }

            // 5. Natural Fatigue Recovery
            if (slaves_active) {
                const base_recovery_slave = fatigue > 99 ? 5 : 1; 
                fatigue = Math.max(0, fatigue - (base_recovery_slave + p.extra_slave_reinvig));
            }
            for (let i = 0; i < p.n_masters; i++) {
                if (mf[i] <= 99) resting[i] = false; 
                const base_recovery_master = mf[i] > 99 ? 5 : 1;
                mf[i] = Math.max(0, mf[i] - (base_recovery_master + p.extra_master_reinvig));
            }

            // 6. HP Regeneration
            if (slaves_active && p.regen > 0) {
                hp = Math.min(initial_hp, hp + p.regen);
            }

            fat_hist.push(slaves_active ? fatigue : (fat_hist.length > 0 ? fat_hist[fat_hist.length-1] : 0));
            hp_hist.push(slaves_active ? hp : 0);
            for (let i = 0; i < p.n_masters; i++) mf_hist[i].push(mf[i]);

            if (p.n_slaves > 0 && !slaves_active && (hp_hist.length > 1 && hp_hist[hp_hist.length - 2] > 0)) { 
                for (let t_fill = turn + 1; t_fill <= p.n_turns; t_fill++) {
                    fat_hist.push(fat_hist[fat_hist.length - 1]); 
                    hp_hist.push(0); 
                    if (p.relief_spell_effect) {
                        const rec = Math.max(0, 1 + calculate_game_DRN() - calculate_game_DRN()); // CORRECTED DRN USAGE
                        for (let mi = 0; mi < p.n_masters; mi++) mf[mi] = Math.max(mf[mi] - rec, 0);
                    }
                    for (let mi = 0; mi < p.n_masters; mi++) {
                        if (mf[mi] <= 99) resting[mi] = false;
                        const recM = (mf[mi] > 99 ? 5 : 1) + p.extra_master_reinvig;
                        mf[mi] = Math.max(0, mf[mi] - recM);
                        mf_hist[mi].push(mf[mi]);
                    }
                }
                break; 
            }
        }

        return {
            cm_lvl_main_spell, m_cost_master_share, s_cost_main_spell, 
            s_mult_main_spell, dmg_cast_main_spell, fat_hist, hp_hist,
            mf_hist, cast_count, total_casts: cast_count.reduce((sum, count) => sum + count, 0)
        };
    }

    function getInputValues() { /* ... same as before ... */ }
    function updateOutputText(r, p) { /* ... same as before ... */ }
    function updatePlot(r, p) { /* ... same as before ... */ }
    function displayNoSpellsMessage(show) { /* ... same as before ... */ }
    function addOneOffSpellToList() { /* ... same as before ... */ }
    function resetForm() { /* ... same as before ... */ }
    function tryRunSimulation() { /* ... same as before ... */ }
    
    // getInputValues, updateOutputText, updatePlot, displayNoSpellsMessage, 
    // addOneOffSpellToList, resetForm, tryRunSimulation, and DOMContentLoaded 
    // listener remain the same as the previous full HTML provided.
    // For brevity, I'll only include the parts that changed or are essential for context here.
    
    // (Make sure to copy the full GUI interaction functions from the previous complete HTML response)

    // --- GUI Interaction (Copied from previous correct version, with minor adjustments if needed for clarity) ---
    function getInputValues() {
        const inputs = {}; const errors = [];
        inputIds.forEach(id => {
            const element = document.getElementById(id); element.classList.remove('error-input'); 
            if (element.type === 'checkbox') inputs[id] = element.checked;
            else {
                const value = parseFloat(element.value);
                if (isNaN(value)) {
                    errors.push(`${element.labels?.[0]?.textContent || id.replace(/_/g, ' ')} must be a valid number.`);
                    element.classList.add('error-input');
                } else inputs[id] = value;
            }
        });
        if (inputs.n_turns < 1 || inputs.n_turns > 10000 || !Number.isInteger(inputs.n_turns)) {
            errors.push('Turns must be an integer between 1 and 10000.'); document.getElementById('n_turns').classList.add('error-input'); }
        if (inputs.mag_scale < -3 || inputs.mag_scale > 3 || !Number.isInteger(inputs.mag_scale)) {
            errors.push('Magic Scale must be an integer between -3 and 3.'); document.getElementById('mag_scale').classList.add('error-input'); }
        if (inputs.n_masters < 1 || !Number.isInteger(inputs.n_masters)) {
            errors.push('Number of Masters must be an integer, at least 1.'); document.getElementById('n_masters').classList.add('error-input'); }
        if (inputs.n_slaves < 0 || !Number.isInteger(inputs.n_slaves)) {
            errors.push('Number of Slaves must be a non-negative integer.'); document.getElementById('n_slaves').classList.add('error-input'); }
        if (inputs.slave_hp < 1 || !Number.isInteger(inputs.slave_hp)) { 
            errors.push('Slave HP must be an integer, at least 1.'); document.getElementById('slave_hp').classList.add('error-input'); }
        if (inputs.rigorPenBonus < 0 || !Number.isInteger(inputs.rigorPenBonus)) {
            errors.push('Rigor Extra Pen must be a non-negative integer.'); document.getElementById('rigorPenBonus').classList.add('error-input'); }
        const nonNegativeIntegerFields = ['path_req', 'caster_lvl', 'slave_lvl', 'communion_mr', 'extra_slave_reinvig', 'extra_master_reinvig', 'regen'];
        nonNegativeIntegerFields.forEach(id => {
            if (inputs[id] < 0 || !Number.isInteger(inputs[id])) {
                errors.push(`${document.getElementById(id).labels?.[0]?.textContent || id.replace(/_/g, ' ')} must be a non-negative integer.`);
                document.getElementById(id).classList.add('error-input');
            }
        });
        if (inputs.enc < 0) { errors.push('Encumbrance (Master) must be non-negative.'); document.getElementById('enc').classList.add('error-input');}
        if (inputs.base_fatigue < 0) { errors.push('Base Fatigue must be non-negative.'); document.getElementById('base_fatigue').classList.add('error-input');}
        if (inputs.initial_slave_fatigue < 0 || inputs.initial_slave_fatigue > 200) {
            errors.push('Initial Slave Fatigue must be between 0 and 200.'); document.getElementById('initial_slave_fatigue').classList.add('error-input');}
        if (inputs.initial_master_fatigue < 0 || inputs.initial_master_fatigue > 200) {
            errors.push('Initial Master Fatigue must be between 0 and 200.'); document.getElementById('initial_master_fatigue').classList.add('error-input');}
        const oneOffSpells = [];
        oneOffSpellsListContainer.querySelectorAll('.listed-one-off-spell').forEach((el, idx) => {
            const t = parseInt(el.dataset.turn), bf = parseFloat(el.dataset.baseFatigue), pr = parseInt(el.dataset.pathReq), cl = parseInt(el.dataset.casterLvl), io = el.dataset.isOffPath === 'true';
            if (isNaN(t)||t<1||!Number.isInteger(t)) errors.push(`One-off #${idx+1} Turn: >=1 int.`); if(isNaN(bf)||bf<0) errors.push(`One-off #${idx+1} BaseFat: >=0.`);
            if (isNaN(pr)||pr<0||!Number.isInteger(pr)) errors.push(`One-off #${idx+1} PReq: >=0 int.`); if(isNaN(cl)||cl<0||!Number.isInteger(cl)) errors.push(`One-off #${idx+1} CLvl: >=0 int.`);
            oneOffSpells.push({turn:t, base_fatigue:bf, path_req:pr, caster_lvl:cl, is_off_path:io});
        });
        inputs.one_off_spells = oneOffSpells;
        if (errors.length > 0) { alert('Input Errors:\n' + errors.join('\n')); throw new Error('Input validation failed'); }
        return inputs;
    }

    function updateOutputText(r, p) { 
        let turns_survived = p.n_turns;
        if (p.n_slaves > 0) { for (let i=0; i<r.hp_hist.length; i++) { if (r.hp_hist[i]<=0) { turns_survived = Math.max(0,i-1); break;}}}
        const output = [
            `Communion Master Level (Main):   ${r.cm_lvl_main_spell.toFixed(0)}`,
            `Master Cost per Cast (Main):    ${r.m_cost_master_share.toFixed(2)}`,
            `Slave Cost per Cast (Main):     ${r.s_cost_main_spell.toFixed(2)} (x${r.s_mult_main_spell.toFixed(1)})`,
            `Damage per Cast (Main):         ${r.dmg_cast_main_spell.toFixed(0)}`,
            `Initial Slave Fatigue:          ${p.initial_slave_fatigue.toFixed(2)}`,
            `Initial Master Fatigue:         ${p.initial_master_fatigue.toFixed(2)}`,
            `Total Main Casts:               ${r.total_casts}`,
            `Turns Survived (Slaves):        ${turns_survived}`
        ];
        outputTextElement.textContent = output.join('\n');
    }

    function updatePlot(r, p) {
        const turns = Array.from({ length: r.hp_hist.length }, (_, i) => i);
        Plotly.newPlot('hp-chart', [{x:turns,y:r.hp_hist,mode:'lines+markers',name:'Slave HP',line:{color:'#28a745'},marker:{size:4}}], 
            {title:'Slave HP Over Time',xaxis:{title:'Turn',autorange:true},yaxis:{title:'Slave HP',range:[Math.min(0,...r.hp_hist)-1,Math.max(10,p.slave_hp*1.1,...r.hp_hist)+1]},showlegend:true,margin:{l:60,r:30,t:50,b:50}}, {responsive:true});
        Plotly.newPlot('fatigue-chart', [{x:turns,y:r.fat_hist,mode:'lines+markers',name:'Slave Fatigue',line:{color:'#007bff'},marker:{size:4}}],
            {title:'Slave Fatigue Over Time',xaxis:{title:'Turn',autorange:true},yaxis:{title:'Slave Fatigue',range:[-5,220]},showlegend:true,margin:{l:60,r:30,t:50,b:50},
            shapes:[{type:'line',xref:'paper',x0:0,x1:1,yref:'y',y0:100,y1:100,line:{color:'rgba(0,0,0,0.3)',dash:'dash'}},{type:'line',xref:'paper',x0:0,x1:1,yref:'y',y0:200,y1:200,line:{color:'rgba(255,0,0,0.3)',dash:'dash'}}]}, {responsive:true});
        Plotly.newPlot('master-fatigue-chart', r.mf_hist.map((mf,i)=>({x:turns,y:mf,mode:'lines',name:`Master ${i+1}`,line:{color:`hsl(${(i*70+40)%360},70%,50%)`}})),
            {title:'Master Fatigue Over Time',xaxis:{title:'Turn',autorange:true},yaxis:{title:'Master Fatigue',range:[-5,220]},showlegend:true,margin:{l:60,r:30,t:50,b:50},
            shapes:[{type:'line',xref:'paper',x0:0,x1:1,yref:'y',y0:100,y1:100,line:{color:'rgba(0,0,0,0.3)',dash:'dash'}}]}, {responsive:true});
    }

    function displayNoSpellsMessage(show) { if(noOneOffSpellsMessage) noOneOffSpellsMessage.style.display = show ? 'block' : 'none';}
    function addOneOffSpellToList() {
        [oneOffTurnInput,oneOffBaseFatigueInput,oneOffPathReqInput,oneOffCasterLvlInput].forEach(el=>el.classList.remove('error-input'));
        const t=parseInt(oneOffTurnInput.value),bf=parseFloat(oneOffBaseFatigueInput.value),pr=parseInt(oneOffPathReqInput.value),cl=parseInt(oneOffCasterLvlInput.value),io=oneOffIsOffPathInput.checked,errs=[];
        if(isNaN(t)||t<1||!Number.isInteger(t)){errs.push('One-off Turn: >=1 int.');oneOffTurnInput.classList.add('error-input');}
        if(isNaN(bf)||bf<0){errs.push('One-off BaseFat: >=0.');oneOffBaseFatigueInput.classList.add('error-input');}
        if(isNaN(pr)||pr<0||!Number.isInteger(pr)){errs.push('One-off PReq: >=0 int.');oneOffPathReqInput.classList.add('error-input');}
        if(isNaN(cl)||cl<0||!Number.isInteger(cl)){errs.push('One-off CLvl: >=0 int.');oneOffCasterLvlInput.classList.add('error-input');}
        if(errs.length>0){alert('Errors in one-off spell:\n'+errs.join('\n'));return;}
        displayNoSpellsMessage(false); const el=document.createElement('div'); el.className='listed-one-off-spell';
        Object.assign(el.dataset,{turn:t,baseFatigue:bf,pathReq:pr,casterLvl:cl,isOffPath:io});
        el.innerHTML=`<span>T${t}: Fat ${bf}, PReq ${pr}, CLvl ${cl}${io?' (Off-Path)':''}</span><button type="button" class="remove-listed-spell">Remove</button>`;
        el.querySelector('.remove-listed-spell').addEventListener('click',()=>{el.remove();if(!oneOffSpellsListContainer.querySelector('.listed-one-off-spell'))displayNoSpellsMessage(true);});
        oneOffSpellsListContainer.appendChild(el);
    }
    function resetForm() {
        inputIds.forEach(id=>{const el=document.getElementById(id);el.classList.remove('error-input');if(el.type==='checkbox')el.checked=defaultValues[id];else el.value=defaultValues[id];});
        oneOffTurnInput.value="1";oneOffBaseFatigueInput.value="50";oneOffPathReqInput.value="1";oneOffCasterLvlInput.value="1";oneOffIsOffPathInput.checked=false;
        [oneOffTurnInput,oneOffBaseFatigueInput,oneOffPathReqInput,oneOffCasterLvlInput].forEach(el=>el.classList.remove('error-input'));
        oneOffSpellsListContainer.innerHTML='<p class="no-one-off-spells-message">No one-off spells added yet.</p>'; displayNoSpellsMessage(true);
        outputTextElement.textContent='Run simulation to see results.'; Plotly.purge('hp-chart');Plotly.purge('fatigue-chart');Plotly.purge('master-fatigue-chart');
        if(applyBattlefieldRigorCheckbox&&rigorMortisDetailsDiv)rigorMortisDetailsDiv.style.display=applyBattlefieldRigorCheckbox.checked?'grid':'none';
    }
    function tryRunSimulation() {
        inputIds.forEach(id=>document.getElementById(id)?.classList.remove('error-input'));
        [oneOffTurnInput,oneOffBaseFatigueInput,oneOffPathReqInput,oneOffCasterLvlInput].forEach(el=>el.classList.remove('error-input'));
        try { const params=getInputValues(); const results=simulate(params); updateOutputText(results,params); updatePlot(results,params); }
        catch(err){console.error('Sim/Validation fail:',err);}
    }
    document.addEventListener('DOMContentLoaded',()=>{
        document.getElementById('simulate_button')?.addEventListener('click',tryRunSimulation);
        document.getElementById('reset_button')?.addEventListener('click',resetForm);
        document.getElementById('add_one_off_spell_button')?.addEventListener('click',addOneOffSpellToList);
        if(applyBattlefieldRigorCheckbox&&rigorMortisDetailsDiv){
            applyBattlefieldRigorCheckbox.addEventListener('change',function(){
                rigorMortisDetailsDiv.style.display=this.checked?'grid':'none';
                if(!this.checked){document.getElementById('rigorPenBonus').value=defaultValues.rigorPenBonus;document.getElementById('rigorPenBonus').classList.remove('error-input');}
            });
        }
        resetForm();
    });
</script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'93d9b3fcbbca456c',t:'MTc0Njg4MjkwMi4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>
</body>
</html>
